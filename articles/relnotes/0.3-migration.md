---
title: Przewodnik dotyczący przeglądu i migracji języka QDK 0,3
description: Opisuje nowe funkcje w Microsoft Quantum Development Kit 0,3 i sposób migrowania istniejących programów pytań i odpowiedzi.
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: a715185059e37e3805caf48e7fae6f5ed3372dba
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426790"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>Informacje o wersji języka QDK 0,3 i przewodnik migracji

Przyjemnością się na wprowadzenie najnowszej aktualizacji zestawu Quantum Development Kit.  Ta strona zawiera omówienie nowych funkcji języka Q # i opisuje sposób [migrowania](#Migration) istniejących programów q # do nowej składni.  Zapoznaj się z naszą kompletną dokumentacją zawierającą pełny [Opis języka Q](xref:microsoft.quantum.guide.basics)#.


## <a name="whats-new"></a>Co nowego 

Aktualizacja 0,3 obejmuje wiele nowych funkcji języka i edytora.

### <a name="overview-of-features"></a>Omówienie funkcji

- Ulepszona integracja narzędzi programistycznych dla programu Visual Studio i Visual Studio Code, w tym:
    - Kompilacja na żywo i opinie dotyczące wpisywania (*vel* podkreślenie falistej).
    - Informacje o aktywowaniu, w tym podsumowania dokumentacji i sygnaturach typów.
    - Obsługa funkcji przejdź do definicji.
    - Łatwa nawigacja do przestrzeni nazw, operacji, funkcji i deklaracji typu.
    - Ulepszone komunikaty diagnostyczne.
- Ulepszenia języka
    - Pojedyncze qubit i inicjalizacje krotki w ramach korzystania z i pożyczania
    - Dekonstrukcja krotki na wszystkich przypisań
    - Iteracja w tablicach
    - Wyrażenia warunkowe
    - Skrót domyślny dla operacji
    - Automatycznie generowane konstruktory typów
    - Modyfikatory wyrażeń


## <a name="editor-features"></a>Funkcje edytora

Zestaw Quantum Development Kit zawiera teraz serwer języka dla Q #, a także integracje klienta dla programu Visual Studio i Visual Studio Code.
Dzięki temu może działać nowy zestaw funkcji IntelliSense wraz ze wskazówkami wyświetlanymi podczas pisania w postaci falistego podkreślenia błędów i ostrzeżeń.
W szczególności, polecenie Przejdź do definicji jest teraz obsługiwane, a informacje o aktywowaniu są wyświetlane wraz z informacjami o typie oraz informacjami z dokumentów zawierających Komentarze. Ponadto dostępne są informacje o symbolach o zdefiniowanych przestrzeniach nazw, operacjach, funkcjach i typach, które umożliwiają szybkie przechodzenie do deklaracji.    
Ta aktualizacja znacznie usprawnia wyświetlanie ogólnych komunikatów diagnostycznych, przez co ułatwia nawigację i precyzowanie zakresów danych diagnostycznych, a także powoduje wyświetlanie dodatkowych szczegółów w aktywnych okienkach. 

W przypadku tej wersji 0,3 serwer języka dołączony do zestawu Quantum Development Kit nie obsługuje wielu obszarów roboczych.
Aby można było korzystać z projektu w VS Code, Otwórz folder główny zawierający sam projekt i wszystkie projekty, do których istnieją odwołania.
Aby można było korzystać z rozwiązania w programie Visual Studio, wszystkie projekty zawarte w rozwiązaniu muszą znajdować się w tym samym folderze co rozwiązanie lub w jednym z jego podfolderów.

## <a name="language-features"></a>Funkcje językowe

W zakresie funkcji języka ta aktualizacja łączy traktowanie różnych wzorców języka.
Konstruktory typów, na przykład, są generowane dla każdego typu zdefiniowanego przez użytkownika i mogą być częściowo stosowane podobnie jak każda inna funkcja.
Innym przykładem jest dekonstrukcja krotki, która jest teraz w pełni obsługiwana we wszystkich przypisaniach. Dotyczy to nie tylko instrukcji let-, mutable i Set, ale również zmiennej iteracji w pętlach for oraz przy użyciu alokacji i pożyczania. Ponadto częściowe dekonstrukcja są nowo obsługiwane z aktualizacją 0,3. podkreślenia w odbudowych wskazują części wartości, które mają zostać zignorowane. 

Poniższy kod ilustruje niektóre z nowych funkcji:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
Ostatnia instrukcja set używa nowego operatora Trzyelementowy, który został wprowadzony z aktualizacją 0,3, aby obsługiwał wyrażenia warunkowe.
Wyrażenie warunkowe jest wyrażeniem formularza `condition ? caseTrue | caseFalse` .
Jak widać w powyższym przykładzie, iteracja przez tablice jest teraz również obsługiwana.

Alokacje w ramach `using` i są możliwe do zablokowania w `borrowing` przypadku pojedynczych qubits, qubitych tablic i zazagnieżdżonych krotek:
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

Dwie nowe dyrektywy generatora specjalizacji `invert` i `distribute` oprócz `auto` nich są wprowadzane w celu zwiększenia kontroli nad sposobem generowania specjalizacji Funktor.
Jawna deklaracja domyślnej `body` specjalizacji w ramach operacji nie jest już obowiązkowa.
Podobnie jak w przypadku funkcji, instrukcje mogą być bezpośrednio dodawane do samej deklaracji operacji, jeśli żadna inna specjalizacja nie zostanie zadeklarowana w obrębie operacji.
W wersji znajduje się skrypt migracji, który ułatwia Migrowanie istniejącego kodu i korzystanie z nowych funkcji języka (zobacz [sekcję w skrypcie migracji](#MigrationScript)).

Istotna zmiana w sposobie traktowania typów zdefiniowanych przez użytkownika obejmuje aktualizację 0,3. Podczas gdy wcześniejsze wersje przechodzą na typy zdefiniowane przez użytkownika jako podtypy ich typów bazowych, nie jest to już przypadek, który przeniesie się dalej (Zobacz również [sekcję dotyczącą istotnych zmian](#BreakingChanges)).  
W ramach tej zmiany wprowadzamy Modyfikatory wyrażeń, które mogą być stosowane do określonych wyrażeń. Wyrażenia "niepodzielne", których Modyfikatory mogą być stosowane do są identyfikatorami, wyrażeniami elementów tablicowych i krotki 1.
Modyfikatory powiążą się ściśle z innymi wyrażeniami Combinator, a w szczególności bliżej niż wyrażenie Call-Expression Combinator `(` `)` . 
`Adjoint`, `Controlled` i nowy operator przyrostkowy "unotoka" `!` jest traktowany jako modyfikatory wyrażeń. Modyfikatory "traktowanie" i "As" nie `Adjoint` `Controlled` wymagają dla wielu przypadków potrzeby nawiasów. Poniższe wyrażenia na przykład są prawidłowe dla `Op` , operacje jednostkowe, `opArr` Tablica operacji jednostkowych i `arg` odpowiedni argument: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
Skrypt migracji spowoduje usunięcie większości zbędnych nawiasów i pełne korzystanie z nowych funkcji. Należy jednak pamiętać, że skrypt nie interpretuje kodu i nie będzie uwzględniać różnych interpretacji `Controlled` Funktor w rzadkich przypadkach (dotyczy to tylko w połączeniu z częściowymi aplikacjami).

Nowy modyfikator `!` rzutuje typ zdefiniowany przez użytkownika na jego typ podstawowy. To rzutowanie zostało uznane za rzutowane w poprzednich wersjach i zostało wykonane automatycznie. W przypadku nowej interpretacji typów zdefiniowanych przez użytkownika ta wartość nie jest już potrzebna, a rzutowanie musi być jawnie wykonane.    
Poniższy przykład ilustruje sposób użycia modyfikatora New: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
Jak można zobaczyć z przykładu, `!` wiąże się bliżej z modyfikatorami prefiksu, takimi jak `Controlled` i `Adjoint` .

## <a name="breaking-changes"></a><a name="BreakingChanges"></a>Istotne zmiany 

Aktualizacja 0,3 jest dostarczana z nowym kompilatorem i zawiera kilku zmian.
Aby ułatwić Aktualizowanie istniejącego kodu, kompilator udostępnia również opcję formatowania, która kompiluje prawidłowy lub nieprawidłowy kod i emituje sformatowany kod Q # na podstawie skompilowanej kompilacji.
Wszystkie zmiany składni zostaną przetworzone automatycznie za pomocą podanego narzędzia. Jednak zmiany w sposobie interpretacji prawidłowego kodu (zmiany semantyczne) mogą wymagać ręcznego wprowadzenia. 

Oprócz zmian wymienionych poniżej, wzorzec, `__*__` gdzie * jest dowolną sekwencją znaków innych niż odstępy, jest zarezerwowany do użytku wewnętrznego i nie może być używany jako nazwa symbolu.  

## <a name="syntax-changes"></a>Zmiany składni 

- Począwszy od wersji 0,3, elementy tablicy nie są już oddzielone średnikami, ale są rozdzielone przecinkami.
- Średnik po drugiej stronie jest wymagany po dyrektywie autogeneracji dla deklaracji specjalizacji.
- Warunki w klauzulach IF-, elif-i until muszą być hermetyzowane w nawiasach. 

W przypadku wszystkich innych składni zmiany kompilator po prostu generuje ostrzeżenie, jeśli używana jest stara składnia.     
Przykładem takiej zmiany jest krotka symboli w specjalizacjach zdefiniowanych przez użytkownika. W poprzednich wersjach deklaracja kontrolowanej lub kontrolowanej specjalizacji została określona dla pojedynczego argumentu symbolicznego, rozpoczynając od 0,3, zaleca się dostarczenie takiej kolekcji symboli dla całej specjalizacji, `...` wskazując, że kompilator powinien migrować symbole z deklaracji możliwej do, jeśli jest to konieczne. 

## <a name="semantic-changes"></a>Zmiany semantyczne 

Największym wpływem na wypróbowanie wersji 0,3 jest sposób, w jaki typy zdefiniowane przez użytkownika są zintegrowane z systemem typów. We wcześniejszych wersjach typy zdefiniowane przez użytkownika zostały uznane za podtype ich typu podstawowego. W tej wersji i przechodzenie do przodu nie jest już tak. Typy zdefiniowane przez użytkownika są teraz uważane za ich własny typ odrębny i nie istnieje automatyczne rzutowanie między typem zdefiniowanym przez użytkownika a jego typem podstawowym. Wszystkie rzutowania muszą zostać jawnie wykonane za pośrednictwem operatora "unotoka" `!` , a w szczególności wymagane jest rzutowanie dostępu do zawartości obiektu typu zdefiniowanego przez użytkownika.  

Modyfikacje systemu typu obejmują również zachowanie wariancji tablic oraz traktowanie obiektów sparametryzowanych typu. Począwszy od 0,3, zarówno tablice modyfikowalne, jak i niezmienne są niezmienne. Ponadto argumenty przekazane do elementu wywoływanego nie mogą być typu sparametryzowanego. W takich przypadkach argumenty typu muszą być przekazane wraz z identyfikator.

Poprzednie wersje kompilatora Q # mogą mieć wartość funkcji, która ma zostać dostarczona, gdy oczekiwana jest wartość operacji, o ile funkcja ma poprawne typy danych wejściowych i wyjściowych. To zamierzone zachowanie, które nie jest określone w specyfikacji języka Q #.
W kompilatorze 0,3 zostało usunięte takie zachowanie, aby wartości funkcji nie były już uznawane za wartości operacji.
Aby zminimalizować zakłócenia w istniejącym kodzie, który opierał się na tej usterce, dodaliśmy funkcję ToOperation w przestrzeni nazw Microsoft. Quantum. Canon, która jawnie konwertuje funkcję na operację z tymi samymi typami wejściowymi i wyjściowymi.

Poniższy przykład ilustruje sposób użycia `ToOperation` funkcji do zmiany funkcji `Square` na operację `op` : 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Wymagania 

Wydanie jest obsługiwane w programie Visual Studio 2017 w wersji 15,8 lub nowszej dla systemu Windows 10, a w Visual Studio Code w wersji 1.27.2 lub nowszej dla systemów Windows 10, macOS i Linux.

Zestaw Quantum Development Kit używa zestaw .NET Core SDK (2,0 lub nowszej).

## <a name="installation"></a>Instalacja  

Postępuj zgodnie z [instrukcjami](../install-guide/index.md)dotyczącymi instalacji.

Mogą pojawić się ostrzeżenia ("znaleziono konflikty między różnymi wersjami" System. odbicie metadanych ", których nie można rozpoznać). Jeśli bieżąca wersja zestaw .NET Core SDK nie jest aktualna.  Jeśli jednak używasz zestaw .NET Core SDK (2,0 lub nowszej), te ostrzeżenia mogą zostać zignorowane.


- Dostępna jest wersja wraz z szeregiem różnych przykładów pokazujących, jak korzystać z istniejących funkcji zestawu Quantum Development Kit oraz nowych funkcji dostępnych w tej wersji. Te przykłady można znaleźć w witrynie GitHub w repozytorium [Microsoft/Quantum](https://github.com/Microsoft/Quantum) .


## <a name="migrating-existing-projects-to-q-03"></a><a name="Migration"></a>Migrowanie istniejących projektów do Q # 0,3 

Jeśli masz istniejące projekty Q # z wersji 0,2 zestawu Quantum Development Kit, poniżej przedstawiono procedurę migrowania tych projektów do najnowszej wersji. Udostępnimy również [skrypt migracji](#MigrationScript) , który pomoże Ci w procesie.

> [!NOTE]
> Projekty muszą zostać uaktualnione w odpowiedniej kolejności. Jeśli masz rozwiązanie z wieloma projektami, zaktualizuj każdy projekt w kolejności, w której się odwołują.


1. W wierszu polecenia uruchom polecenie `dotnet clean`, aby usunąć wszystkie istniejące dane binarne i pliki pośrednie.
2. W edytorze tekstów Edytuj plik. csproj, aby zmienić wersję wszystkich elementów "Microsoft. Quantum" `PackageReference` na wersję 0.3.1811.2802-Preview, na przykład:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. W wierszu polecenia Użyj narzędzia formatowania zintegrowanego z kompilatorem wiersza polecenia, aby rozwiązać wszystkie zmiany składniowe, uruchamiając następujące polecenie:`dotnet msbuild /t:qsharpformat`  
    - Pliki zostaną zmigrowane w miejscu. Kopia zapasowa wszystkich oryginalnych plików zostanie skopiowana do`obj\qsharp\.backup`
    - Narzędzie formatowania kompiluje projekt, ignorując wszystkie błędy kompilacji i generuje sformatowany kod Q w oparciu o kompilację kompilacji. 
       Dowolny nierozpoznany symbol (np. niezdefiniowana nazwa zmiennej) zostanie zastąpiony przez tekst zastępczy, który należy zastąpić ręcznie po formatowaniu. W takim przypadku formatowanie powiedzie się, gdy zostanie wygenerowane Ostrzeżenie dla odnośnego pliku.     
    - Formatowanie i w szczególności dowolny biały znak w pliku zostanie zmieniony w wyemitowanym kodzie. Komentarze zostaną zachowane.   
5. Po uruchomieniu tego może być nadal konieczne ręczne adresowanie zmian semantycznych w przypadkach, gdy interpretacja semantyczna kodu została zmieniona. Wszystkie te błędy będą raportowane przez funkcję IntelliSense w programie Visual Studio lub Visual Studio Code.
    - Otwórz folder główny projektu lub zawarte rozwiązanie w programie Visual Studio 2017 lub Visual Studio Code.
    - Po otwarciu pliku qs w edytorze powinny zostać wyświetlone dane wyjściowe rozszerzenia języka Q# w oknie danych wyjściowych.
    - Po pomyślnym załadowaniu projektu (zostanie to zasygnalizowane w oknie danych wyjściowych) otwórz każdy plik i ręcznie rozwiąż wszystkie pozostałe problemy.


> [!NOTE]
> * W przypadku wersji 0,3 serwer języka dołączony do zestawu Quantum Development Kit nie obsługuje wielu obszarów roboczych.
> * Aby można było korzystać z projektu w edytorze Visual Studio Code, otwórz folder główny zawierający projekt i wszystkie przywoływane projekty.   
> * Aby można było korzystać z rozwiązania w programie Visual Studio, wszystkie projekty zawarte w rozwiązaniu muszą znajdować się w tym samym folderze co rozwiązanie lub w jednym z jego podfolderów.  
> * Odwołania między projektami migrowanymi do 0,3 i wyższymi i projektami korzystającymi ze starszych wersji pakietu **nie** są obsługiwane.




## <a name="migration-script"></a><a name="MigrationScript"></a>Skrypt migracji 

Aby ułatwić migrację projektu, dostępny jest skrypt programu PowerShell, który można pobrać [tutaj](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Ten skrypt ułatwia Migrowanie projektów z wersji 0,2 zestawu Quantum Development Kit do korzystania z wersji 0,3.

> [!NOTE]
> Skrypt migracji wymaga uruchomienia programu Windows PowerShell lub PowerShell Core.
> Program Windows PowerShell jest wstępnie zainstalowany z systemem Windows 10.
> Pobierz rdzeń programu PowerShell dla systemu Windows, macOS lub Linux pod adresem https://github.com/PowerShell/PowerShell .

Skrypt wykonuje następujące cztery kroki:

- Projekt został skompilowany przy użyciu poprzedniej wersji zestawu Quantum Development Kit, aby upewnić się, że migracja będzie prawdopodobnie zakończona pomyślnie. Ten krok można pominąć przy użyciu `-Force` parametru do skryptu.
- Nowe szablony projektu są zainstalowane.
- Projekt został zaktualizowany tak, aby korzystał z bieżącej wersji zestawu Quantum Development Kit.
- Narzędzie formatowania dostępne w wersji 0,3 zestawu Quantum Development Kit jest stosowane do automatycznego rozwiązywania większości zmian, opisanych powyżej.

Po wykonaniu tych czterech kroków mogą występować inne problemy z migracją, które muszą zostać obsłużone ręcznie.
Korzystanie z najnowszej wersji rozszerzeń Quantum Development Kit dla programu Visual Studio 2017 i Visual Studio Code może pomóc w łatwym wykorzystaniu tych problemów.

Dokumentację skryptu można uzyskać, uruchamiając jedno z następujących poleceń w folderze, w którym znajduje się skrypt:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> Domyślnie system Windows zapobiega wykonywaniu skryptów jako miary zabezpieczeń.
> Aby zezwolić na uruchamianie skryptów `qdk-migrate.ps1` w systemie Windows, może być konieczna zmiana zasad wykonywania.
> Aby to zrobić, uruchom `Set-ExecutionPolicy` polecenie:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> Zasady wykonywania zostaną następnie przywrócone po zakończeniu działania programu PowerShell.
> Jeśli chcesz zapisać zasady wykonywania, użyj innej wartości dla `-Scope` :
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

