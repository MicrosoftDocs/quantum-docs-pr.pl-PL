---
title: Przegląd programu Q#
description: Poznaj podstawową strukturę programu Quantum i sposób, w jaki reprezentuje przekształcenia w Stanach Quantum.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907702"
---
# <a name="q-program-overview"></a><span data-ttu-id="431d4-103">Przegląd programu Q#</span><span class="sxs-lookup"><span data-stu-id="431d4-103">Q# program overview</span></span>

<span data-ttu-id="431d4-104">Q # to skalowalny, wielowymiarowy, specyficzny dla domeny język programowania dla przetwarzania Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="431d4-105">Q # to język programowania Quantum w systemie, który może służyć do opisywania sposobu wykonywania instrukcji na maszynach Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="431d4-106">Maszyny, które mogą być przeznaczone do zakresu od symulatorów do rzeczywistego sprzętu Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="431d4-107">Polecenie Q # jest skalowalne: może służyć do pisania prostych programów demonstracyjnych, takich jak teleport, które działają na kilku qubits, ale również obsługuje pisanie dużych, zaawansowanych programów, takich jak symulacje złożonych cząsteczek, które będą wymagały dużych maszyn z milionami qubits.</span><span class="sxs-lookup"><span data-stu-id="431d4-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="431d4-108">Mimo że duże maszyny fizyczne są nadal w przyszłości, funkcja Q # umożliwia programistom programowanie złożonych algorytmów Quantum teraz.</span><span class="sxs-lookup"><span data-stu-id="431d4-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="431d4-109">Co więcej, funkcja Q # obsługuje różne zadania, takie jak debugowanie, profilowanie, szacowanie zasobów i pewne symulacje specjalnego przeznaczenia w sposób skalowalny.</span><span class="sxs-lookup"><span data-stu-id="431d4-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="431d4-110">Z perspektywy technicznej, program Quantum może być traktowany jako określony zestaw funkcji klasycznych, które po wywołaniu generują obwody Quantum jako ich efekty uboczne.</span><span class="sxs-lookup"><span data-stu-id="431d4-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="431d4-111">Istotną konsekwencją tego widoku jest to, że program pisany w języku Q # nie bezpośrednio modeluje qubits, ale raczej opisuje, jak klasyczny formant współdziała z tymi qubitsami.</span><span class="sxs-lookup"><span data-stu-id="431d4-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="431d4-112">W związku z tym pytania Q nie definiują w ten sposób Stanów Quantum i innych właściwości Mechanics Quantum, ale raczej pośrednio przez działanie różnych podprocedur zdefiniowanych w języku.</span><span class="sxs-lookup"><span data-stu-id="431d4-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="431d4-113">Na przykład rozważmy stan $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ omówiony w przewodniku dotyczący [koncepcji przetwarzania Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="431d4-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="431d4-114">Aby przygotować ten stan w Q #, używamy faktów, że qubits są inicjowane w stanie $ \ket{0}$, i że $ \ket{+} = H\ket{0}$, gdzie $H $ to Hadamard Transform:</span><span class="sxs-lookup"><span data-stu-id="431d4-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="431d4-115">Q # tranformations Stanów Quantum</span><span class="sxs-lookup"><span data-stu-id="431d4-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="431d4-116">Ważne jest, aby podczas pisania powyższego programu nie odwoływał się jawnie do stanu z pytaniami Q #, ale zamiast opisywania sposobu, w jaki został on *przekształcony* przez nasz program.</span><span class="sxs-lookup"><span data-stu-id="431d4-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="431d4-117">W ten sposób podobnie jak program do cieniowania grafiki gromadzi opis przekształceń do każdego wierzchołka, program Quantum w Q # gromadzi przekształcenia do Stanów Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="431d4-118">Pozwala to na całkowite niezależny od informacji o stanie *Quantum nawet na* każdej maszynie docelowej, co może mieć różne interpretacje w zależności od maszyny.</span><span class="sxs-lookup"><span data-stu-id="431d4-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="431d4-119">Z perspektywy programu Q # qubit jest całkowicie nieprzezroczystym odwołaniem do wewnętrznej struktury maszyny docelowej.</span><span class="sxs-lookup"><span data-stu-id="431d4-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="431d4-120">Program Q # nie ma możliwości Introspect stanu qubit, jego reprezentacji na komputerze docelowym lub nawet tego, czy jest to ten sam qubit, co inne qubit dostępne dla programu.</span><span class="sxs-lookup"><span data-stu-id="431d4-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="431d4-121">Zamiast tego program może wywoływać operacje, takie jak `Measure`, aby poznać informacje z qubit i wywoływać operacje, takie jak `X` i `H` do działania na stanie qubit.</span><span class="sxs-lookup"><span data-stu-id="431d4-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="431d4-122">Te operacje nie mają wewnętrznej definicji w języku i są przeznaczone tylko dla maszyny docelowej używanej do uruchamiania określonego programu Q #.</span><span class="sxs-lookup"><span data-stu-id="431d4-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="431d4-123">Program Q # ponownie łączy te operacje jako zdefiniowane przez maszynę docelową w celu utworzenia nowych, wyższych operacji na potrzeby obliczeń Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="431d4-124">W ten sposób Q # ułatwia wyrażanie logiki podstawowych algorytmów Quantum i hybrydowych, a także ogólne w odniesieniu do struktury maszyny docelowej lub symulatora.</span><span class="sxs-lookup"><span data-stu-id="431d4-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="431d4-125">Operacje i funkcje pytań i odpowiedzi</span><span class="sxs-lookup"><span data-stu-id="431d4-125">Q# operations and functions</span></span>

<span data-ttu-id="431d4-126">W konkretnym przypadku program Q # składa się z co najmniej jednej *operacji*, co najmniej jednej *funkcji*i typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="431d4-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="431d4-127">Operacje są używane do opisywania transformacji stanu maszyny Quantum i są najbardziej podstawowymi blokami konstrukcyjnymi programów Q #.</span><span class="sxs-lookup"><span data-stu-id="431d4-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="431d4-128">Każda operacja zdefiniowana w Q # może następnie wywołać dowolną liczbę innych operacji, łącznie z wbudowanymi *wewnętrznymi* operacjami implementowanymi przez maszynę docelową.</span><span class="sxs-lookup"><span data-stu-id="431d4-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="431d4-129">Po skompilowaniu każda operacja jest reprezentowana jako typ klasy .NET, który można dostarczyć dla maszyn docelowych.</span><span class="sxs-lookup"><span data-stu-id="431d4-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="431d4-130">W przeciwieństwie do operacji, funkcje są używane do opisywania przejrzystie klasycznego zachowania i nie mają żadnych efektów poza obliczaniem klasycznej wartości wyjściowej.</span><span class="sxs-lookup"><span data-stu-id="431d4-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="431d4-131">Q # jest silnie wpisaną językiem i zawiera zestaw wbudowanych typów pierwotnych, a także obsługę typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="431d4-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="431d4-132">W dalszej części tego przewodnika zobaczymy, jak używać różnych pojęć i konstrukcji języka, aby pomóc nam definiować złożone programy Quantum za pośrednictwem podstawowych bloków konstrukcyjnych operacji, funkcji i typów.</span><span class="sxs-lookup"><span data-stu-id="431d4-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="431d4-133">Struktura plików źródłowych Q #</span><span class="sxs-lookup"><span data-stu-id="431d4-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="431d4-134">Co więcej, plik źródłowy Q # składa się z *deklaracji przestrzeni nazw*, która określa przestrzeń nazw platformy .NET, która będzie zawierać definicje w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="431d4-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="431d4-135">Definicje z innych plików źródłowych i bibliotek Q # można uwzględnić przy użyciu instrukcji `open`.</span><span class="sxs-lookup"><span data-stu-id="431d4-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="431d4-136">Na przykład większość operacji definiujących podstawowe bramy jest definiowana w przestrzeni nazw <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="431d4-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="431d4-137">Aby udostępnić ten kod, po prostu `open` tę przestrzeń nazw u góry każdego pliku:</span><span class="sxs-lookup"><span data-stu-id="431d4-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="431d4-138">W przestrzeni nazw każdy plik źródłowy Q # może definiować dowolną kombinację *operacji*, *funkcji*i *typów zdefiniowanych przez użytkownika*.</span><span class="sxs-lookup"><span data-stu-id="431d4-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="431d4-139">W pozostałej części tej sekcji opiszemy każdą z nich i dostarczymy przykłady ich użycia w programie w celu zapewnienia użytecznych programów Quantum.</span><span class="sxs-lookup"><span data-stu-id="431d4-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
