---
title: Podstawowe informacje o numerze Q
description: 'Podstawowe pojęcia dotyczące pytań i odpowiedzi #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: e77b52d1a6eb7e2f62ab12dedd75d00ac8fec4be
ms.sourcegitcommit: a35498492044be4018b4d1b3b611d70a20e77ecc
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/03/2020
ms.locfileid: "84327326"
---
# <a name="q-basics"></a><span data-ttu-id="6a452-103">Podstawowe informacje o numerze Q</span><span class="sxs-lookup"><span data-stu-id="6a452-103">Q# Basics</span></span>

<span data-ttu-id="6a452-104">W tej sekcji przedstawiamy krótkie wprowadzenie do podstawowych bloków konstrukcyjnych języka Q #.</span><span class="sxs-lookup"><span data-stu-id="6a452-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="6a452-105">Aby uzyskać szybki przegląd informacji o tym, co to jest funkcja Q # i gdzie pasuje do podstawowego składnika zestawu Quantum Development Kit, możesz sprawdzić, [co to jest Q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="6a452-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="6a452-106">Co to jest program Quantum?</span><span class="sxs-lookup"><span data-stu-id="6a452-106">What is a quantum program?</span></span>

<span data-ttu-id="6a452-107">Z perspektywy technicznej, program Quantum może być traktowany jako określony zestaw klasycznych podprocedur, które, po wywołaniu, wykonują pewne operacje w systemie Quantum.</span><span class="sxs-lookup"><span data-stu-id="6a452-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="6a452-108">Istotną konsekwencją tego widoku jest to, że program pisany w języku Q # nie bezpośrednio modeluje qubits, ale raczej opisuje, jak klasyczny formant współdziała z tymi qubitsami.</span><span class="sxs-lookup"><span data-stu-id="6a452-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="6a452-109">Zgodnie z projektem, Q # nie definiuje bezpośrednio Stanów Quantum lub innych właściwości Quantum Mechanics.</span><span class="sxs-lookup"><span data-stu-id="6a452-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="6a452-110">Na przykład rozważmy stan $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ omówiony w przewodniku [koncepcji obliczeniowej usługi Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="6a452-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="6a452-111">Aby przygotować ten stan w Q #, używamy faktów, że qubits są inicjowane w stanie $ \ket {0} $ i że $ \ket{+} = H\ket {0} $, gdzie $H $ to Hadamard przekształcenia, implementowane przez [ `H` Operation] (] (linki XREF: Microsoft. Quantum. wewnętrzna. H):</span><span class="sxs-lookup"><span data-stu-id="6a452-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="6a452-112">Stany Quantum w Q #</span><span class="sxs-lookup"><span data-stu-id="6a452-112">Quantum states in Q#</span></span>

<span data-ttu-id="6a452-113">Ważne jest, aby podczas pisania powyższego programu nie odwoływał się jawnie do stanu z pytaniami Q #, ale zamiast opisywania sposobu, w jaki został on *przekształcony* przez nasz program.</span><span class="sxs-lookup"><span data-stu-id="6a452-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="6a452-114">Pozwala to na całkowite niezależny od informacji o stanie *Quantum nawet na* każdej maszynie docelowej, co może mieć różne interpretacje w zależności od maszyny.</span><span class="sxs-lookup"><span data-stu-id="6a452-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="6a452-115">Program Q # nie ma możliwości Introspect stanu qubit.</span><span class="sxs-lookup"><span data-stu-id="6a452-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="6a452-116">Zamiast tego program może wywoływać operacje, takie jak [`Measure`](xref:microsoft.quantum.intrinsic.measure) Aby poznać informacje z qubit i wywoływać operacje, takie jak [`X`](xref:microsoft.quantum.intrinsic.x) i [`H`](xref:microsoft.quantum.intrinsic.h) do działania na stanie qubit.</span><span class="sxs-lookup"><span data-stu-id="6a452-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="6a452-117">Operacje, *które faktycznie są* wykonywane, są tworzone wyłącznie przez maszynę docelową używaną do uruchamiania określonego programu Q #.</span><span class="sxs-lookup"><span data-stu-id="6a452-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="6a452-118">Na przykład, jeśli uruchamiasz program w [symulatorze pełnego stanu](xref:microsoft.quantum.machines.full-state-simulator), symulator wykona odpowiednie operacje matematyczne w symulowanym systemie Quantum.</span><span class="sxs-lookup"><span data-stu-id="6a452-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="6a452-119">Jednak w przyszłości, gdy maszyna docelowa jest rzeczywistym komputerem z systemem Quantum, wywołanie takich operacji w Q # spowoduje skierowanie komputera Quantum do wykonywania odpowiednich *rzeczywistych* operacji na *rzeczywistym* systemie Quantum (np. precyzyjne impulsy laserowe).</span><span class="sxs-lookup"><span data-stu-id="6a452-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="6a452-120">Program Q # ponownie łączy te operacje jako zdefiniowane przez maszynę docelową w celu utworzenia nowych, wyższych operacji na potrzeby obliczeń Quantum.</span><span class="sxs-lookup"><span data-stu-id="6a452-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="6a452-121">W ten sposób Q # ułatwia wyrażanie logiki podstawowych algorytmów Quantum i hybrydowych procesów Quantum — klasycznych, a także ogólnie w odniesieniu do struktury maszyny docelowej lub symulatora.</span><span class="sxs-lookup"><span data-stu-id="6a452-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="6a452-122">Operacje i funkcje pytań i odpowiedzi</span><span class="sxs-lookup"><span data-stu-id="6a452-122">Q# operations and functions</span></span>

<span data-ttu-id="6a452-123">W konkretnym przypadku program Q # składa się z *operacji*, *funkcji*i wszystkich typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="6a452-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="6a452-124">Operacje są używane do opisywania transformacji systemów Quantum i są najbardziej podstawowymi blokami konstrukcyjnymi programów Q #.</span><span class="sxs-lookup"><span data-stu-id="6a452-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="6a452-125">Każda operacja zdefiniowana w Q # może następnie wywołać dowolną liczbę innych operacji.</span><span class="sxs-lookup"><span data-stu-id="6a452-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="6a452-126">W przeciwieństwie do operacji, funkcje są używane do opisywania przejrzystie *deterministycznych* zachowań klasycznych i nie mają żadnych efektów poza obliczaniem klasycznych wartości.</span><span class="sxs-lookup"><span data-stu-id="6a452-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="6a452-127">Załóżmy na przykład, że chcemy zmierzyć nasze qubits na końcu programu i dodać wyniki pomiarów do tablicy.</span><span class="sxs-lookup"><span data-stu-id="6a452-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="6a452-128">W tym przypadku `Measure` jest to *operacja* , która instruuje maszynę docelową, aby wykonywała pomiary na (rzeczywista lub symulowana) qubits, a klasyczny proces dodawania zwracanych wyników do tablicy zostanie obsłużony przez *funkcje*.</span><span class="sxs-lookup"><span data-stu-id="6a452-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="6a452-129">Razem operacje i funkcje są *określane jako możliwe*do wypróbowania, a ich podstawowa struktura i zachowanie są wprowadzane na stronie [operacje i funkcje w obszarze Q #](xref:microsoft.quantum.guide.operationsfunctions) .</span><span class="sxs-lookup"><span data-stu-id="6a452-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="6a452-130">Omówienie składni Q #</span><span class="sxs-lookup"><span data-stu-id="6a452-130">Q# syntax overview</span></span>

<span data-ttu-id="6a452-131">Składnia języka opisuje różne kombinacje symboli, które tworzą poprawny w składni program.</span><span class="sxs-lookup"><span data-stu-id="6a452-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="6a452-132">W Q # możemy sklasyfikować elementy jego składni w trzech różnych grupach: typy, wyrażenia i instrukcje.</span><span class="sxs-lookup"><span data-stu-id="6a452-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="6a452-133">Typy</span><span class="sxs-lookup"><span data-stu-id="6a452-133">Types</span></span>
<span data-ttu-id="6a452-134">Q # to wulgarny język, w taki sposób, że staranne użycie typów może pomóc kompilatorowi zapewnić silne gwarancje dotyczące programów Q # w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="6a452-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="6a452-135">Oprócz standardowych i opartych na Quantum typów pierwotnych (np.,, `Int` `Bool` `Qubit` i `Result` ), Q # zapewnia obsługę typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="6a452-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="6a452-136">Wszystkie typy pierwotne Q # są opisane na stronie [typy w q #](xref:microsoft.quantum.guide.types) , wraz ze szczegółami dotyczącymi typów tablicowych i krotek oraz jak definiować nowe typy w pliku q #.</span><span class="sxs-lookup"><span data-stu-id="6a452-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="6a452-137">Wyrażenia</span><span class="sxs-lookup"><span data-stu-id="6a452-137">Expressions</span></span>
<span data-ttu-id="6a452-138">Wyrażenie w języku programowania jest kombinacją jednej lub więcej stałych, zmiennych, operatorów i funkcji interpretowanych przez język programowania i obliczanych w określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="6a452-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="6a452-139">W przypadku każdego typu w języku wyrażenia tego typu mogą być *literałami* lub symbolami związanymi z wartością tego typu.</span><span class="sxs-lookup"><span data-stu-id="6a452-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="6a452-140">Na przykład, `5` to `Int` literał (również wyrażenie typu `Int` ) i jeśli symbol `count` jest powiązany z wartością całkowitą `5` , `count` jest również wyrażeniem liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="6a452-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="6a452-141">Ponadto wyrażenie może składać się z innych wyrażeń połączonych z określonymi operatorami.</span><span class="sxs-lookup"><span data-stu-id="6a452-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="6a452-142">W związku z tym inny przykład `Int` wyrażenia, którego wynikiem `5` jest wartość `2+3` .</span><span class="sxs-lookup"><span data-stu-id="6a452-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="6a452-143">Możliwe wyrażenia typów w Q #, a także zgodne operatory, których można użyć do ich tworzenia, są szczegółowo opisane w [wyrażeniach typu na stronie Q #](xref:microsoft.quantum.guide.expressions) .</span><span class="sxs-lookup"><span data-stu-id="6a452-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="6a452-144">Instrukcje</span><span class="sxs-lookup"><span data-stu-id="6a452-144">Statements</span></span> 
<span data-ttu-id="6a452-145">Instrukcja jest jednostką składniową bezwzględnego języka programowania, która wyraża pewne działania do przeprowadzenia. Różnice instrukcji z wyrażeniami w tych instrukcjach nie zwracają wyników i są wykonywane wyłącznie dla ich efektów ubocznych, natomiast wyrażenia zawsze zwracają wynik i często nie mają efektów ubocznych.</span><span class="sxs-lookup"><span data-stu-id="6a452-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="6a452-146">Takie rozróżnienie jest często obserwowane w wyrazach: wyrażenie jest oceniane, podczas gdy instrukcja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="6a452-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="6a452-147">Bardzo podstawowy przykład instrukcji w Q # przypisuje symbol do wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="6a452-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="6a452-148">Nieco bardziej interesujący przykład to `for` instrukcja, która obsługuje iterację i zawiera *blok instrukcji*.</span><span class="sxs-lookup"><span data-stu-id="6a452-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="6a452-149">Załóżmy, że `qubits` symbol jest powiązany z rejestrem qubits (technicznie typu `Qubit[]` , czyli tablicą `Qubit` typów).</span><span class="sxs-lookup"><span data-stu-id="6a452-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="6a452-150">Następnie</span><span class="sxs-lookup"><span data-stu-id="6a452-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="6a452-151">jest instrukcją, która wykonuje iterację na każdym qubit w rejestrze, wykonując `H` operację na każdym z nich.</span><span class="sxs-lookup"><span data-stu-id="6a452-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="6a452-152">Należy zauważyć, że `H(qubit);` jest również instrukcją w samej siebie.</span><span class="sxs-lookup"><span data-stu-id="6a452-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="6a452-153">W rzeczywistości każde wyrażenie wywołania typu `Unit` (te, które nie zwracają żadnych informacji) mogą być używane jako instrukcja.</span><span class="sxs-lookup"><span data-stu-id="6a452-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="6a452-154">Jest to głównie używane podczas wywoływania operacji na qubits, które zwracają, `Unit` ponieważ celem instrukcji jest zmodyfikowanie niejawnego stanu Quantum.</span><span class="sxs-lookup"><span data-stu-id="6a452-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="6a452-155">Instrukcje oceny wyrażeń wymagają zakończenia średnika.</span><span class="sxs-lookup"><span data-stu-id="6a452-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="6a452-156">Niemal każdy aspekt programu Q # jest kompilowany przy użyciu instrukcji, więc żadna pojedyncza strona nie może obejmować wszystkich informacji odnoszących się do nich.</span><span class="sxs-lookup"><span data-stu-id="6a452-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="6a452-157">Jednak ich struktury i formatowanie leksykalne są opisane na stronie [struktury plików q #](xref:microsoft.quantum.guide.filestructure) , przypisanie powiązania symboli i zakres w [zmiennych w q #](xref:microsoft.quantum.guide.variables)i pętle przepływu sterowania, takie jak `for` w [przepływie sterowania w kontrolce q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="6a452-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="6a452-158">Następne kroki</span><span class="sxs-lookup"><span data-stu-id="6a452-158">Next steps</span></span>
<span data-ttu-id="6a452-159">W pozostałej części tego przewodnika pokazano, jak używać funkcji Q # do konstruowania złożonych programów Quantum za pośrednictwem podstawowych bloków konstrukcyjnych operacji, funkcji i typów.</span><span class="sxs-lookup"><span data-stu-id="6a452-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="6a452-160">Aby rozpocząć, możesz rozpocząć uczenie się o [typach w Q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="6a452-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="6a452-161">Jeśli chcesz dowiedzieć się więcej na temat podstaw i motywacji za Q #, zapoznaj się z informacjami o [tym, dlaczego potrzebuję q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="6a452-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
