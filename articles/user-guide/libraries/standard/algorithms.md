---
title: 'Algorytmy Quantum w Q#'
description: Poznaj podstawowe algorytmy przetwarzania Quantum, w tym wzmocnienie amplitudy, transformację Fouriera, Draper i Beauregard, a także oszacowania faz.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 982103876b00718aa3b42c6bc3a07d242cde7594
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692217"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="95596-103">Algorytmy Quantum</span><span class="sxs-lookup"><span data-stu-id="95596-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="95596-104">Wzmacnianie amplitudy</span><span class="sxs-lookup"><span data-stu-id="95596-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="95596-105">*Wzmocnienie amplitudy* to jedno z podstawowych narzędzi przetwarzania Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="95596-106">Jest to podstawowe koncepcje, które opierają się na wyszukiwaniu Grover, ocenie amplitudy i wielu algorytmach uczenia maszynowego Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="95596-107">Istnieje wiele wariantów, a Q# firma Microsoft udostępnia ogólną wersję opartą na WzOblivious amplitudy ze środkami częściowymi, aby zapewnić szeroki zakres aplikacji.</span><span class="sxs-lookup"><span data-stu-id="95596-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="95596-108">Centralnym pomysłem związanym z wzmocnieniem amplitudy jest wzmocnienie prawdopodobieństwa pożądanego wyniku, wykonując sekwencję odbicia.</span><span class="sxs-lookup"><span data-stu-id="95596-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="95596-109">Te odbicia obracają stan początkowy bliżej żądanego stanu docelowego, często nazywanego stanem oznaczonym.</span><span class="sxs-lookup"><span data-stu-id="95596-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="95596-110">W przypadku, gdy prawdopodobieństwo mierzenia stanu początkowego w oznaczonym stanie to $ \sin ^ 2 (\theta) $, po zastosowaniu wzmocnienia amplitudy $m $ razy prawdopodobieństwo sukcesu stanie się $ \sin ^ 2 ((2 mln + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="95596-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="95596-111">Oznacza to, że jeśli $ \theta = \ pi/[2 (2n + 1)] $ dla niektórych wartości $n $, wzmocnienie amplitudy jest w stanie zwiększyć prawdopodobieństwo sukcesu do $100 \\ % $ po $n $ iteracji wzmocnienia amplitudy.</span><span class="sxs-lookup"><span data-stu-id="95596-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="95596-112">Ponieważ $ \theta = \sin ^ {-1} (\sqrt{\Pr (Success)}) $ oznacza to, że liczba iteracji koniecznych do uzyskania sukcesu jest mniejsza niż oczekiwana liczba, która jest niedeterministyczna, przy użyciu losowego próbkowania.</span><span class="sxs-lookup"><span data-stu-id="95596-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="95596-113">Każda iteracja wzmocnienia amplitudy wymaga określenia dwóch operatorów odbicia.</span><span class="sxs-lookup"><span data-stu-id="95596-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="95596-114">W przypadku $Q $ jest iteracja wzmocnienia amplitudy i $P _0 $ jest operatorem rzutnika w miejscu początkowym i $P _1 $ jest projektorem w oznaczonym miejscu, a następnie $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="95596-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="95596-115">Wycofaj, że projektor jest operatorem hermitian, który ma eigenvalues $ + $1 i $0 $ i jako wynik $ (\boldone-2P_0) $ jest jednostką, ponieważ ma eigenvalues, które są korzeniami aparatu Unity (w tym przypadku $ \Pm $1).</span><span class="sxs-lookup"><span data-stu-id="95596-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="95596-116">Przykładowo Rozważmy przypadek wyszukiwania Grover z początkowym stanem $H ^ {\otimes n} \ket {0} $ i oznaczonym stanem $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ i $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="95596-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="95596-117">W większości zastosowań wzmocnienia amplitudy $P _0 $ będzie projektorem w stanie początkowym, co $P _0 = \boldone-2 \ KET {\ psi} \ bra {\ psi} $ dla niektórych wektorów $ \ket{\psi} $; Jednak w przypadku Oblivious amplitudy amplication $P _0 $ będzie zazwyczaj projektować w wielu stanach Quantum (tj. liczebność $ + $1 eigenvalue $P _0 $ jest większy niż $1 $).</span><span class="sxs-lookup"><span data-stu-id="95596-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="95596-118">Logika za wzmocnieniem amplitudy następuje bezpośrednio z eigenego dekompozycji $Q $.</span><span class="sxs-lookup"><span data-stu-id="95596-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="95596-119">W odniesieniu do eigenvectors $Q $, że stan początkowy ma niezerową pomoc techniczną, można pokazać, że są to liniowe kombinacje $ + $1 eigenvectors $P _0 $ i $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="95596-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="95596-120">W odniesieniu do stanu początkowego wzmocnienia amplitudy (przy założeniu, że jest to $ + $1 eigenvector $P _0 $) można napisać jako $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (^ ^ {i\theta} \ KET {\ psi_ +} + e ^ {-i\theta} \ KET {\ psi_-} \right), $ $ WHERE $ \ket{\ psi_ \Pm} $ to eigenvectors of $Q $ with eigenvalues $e ^ {\Pm 2i \ teta} $ i ma pomoc techniczną dla $ + $1 eigenvectors of $P _0 $ i $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="95596-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="95596-121">Fakt, że eigenvalues są $e ^ {\Pm i \theta} $ oznacza, że operator $Q $ wykonuje obrót w dwuwymiarowym miejscu, określonym przez dwa projektory i początkowym stanie, w którym kąt obrotu to $2 \ TETA $.</span><span class="sxs-lookup"><span data-stu-id="95596-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="95596-122">To dlatego po $m $ iteracji $Q $ prawdopodobieństwo sukcesu to $ \sin ^ 2 ([2 mln + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="95596-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="95596-123">Inną przydatną właściwością, która pochodzi z tego, jest to, że eigenvalue $ \theta $ jest bezpośrednio związany z prawdopodobieństwem, że stan początkowy zostanie oznaczony (w przypadku, gdy $P _0 $ jest projektorem tylko w stanie początkowym).</span><span class="sxs-lookup"><span data-stu-id="95596-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="95596-124">Ponieważ eigenphases $Q $ to $2 \ teta = 2 \ Sin ^ {-1} (\sqrt{\Pr (Success)}) $, wtedy, gdy stosujemy szacowanie fazy do $Q $, możemy poznać prawdopodobieństwo sukcesu dla procedury jednostki Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="95596-125">Jest to przydatne, ponieważ wymaga dwukwadratowych zastosowań procedury Quantum, aby poznać prawdopodobieństwo sukcesu, niż byłoby to konieczne.</span><span class="sxs-lookup"><span data-stu-id="95596-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="95596-126">Q# wprowadza wzmocnienie amplitudy jako specjalizację wzmocnienia amplitudy Oblivious.</span><span class="sxs-lookup"><span data-stu-id="95596-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="95596-127">Wzmocnienie amplitudy Oblivious zdobywa ten moniker, ponieważ projektor na początku eigenspace nie musi być projektorem w stanie początkowym.</span><span class="sxs-lookup"><span data-stu-id="95596-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="95596-128">W tym sensie protokół jest Oblivious do stanu początkowego.</span><span class="sxs-lookup"><span data-stu-id="95596-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="95596-129">Najważniejszym zastosowaniem wzmocnienia amplitudy Oblivious jest w niektórych *liniowych kombinacjach* metod symulacji hamiltonian jednostkowych, w którym stan początkowy jest nieznany, ale zmienia się Entangled za pomocą rejestru Ancilla w protokole symulacji.</span><span class="sxs-lookup"><span data-stu-id="95596-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="95596-130">Jeśli ten rejestr Ancilla był mierzony jako wartość stała, powiedzmy $0 $, a następnie takie metody symulacji stosują odpowiednią transformację jednostkową do pozostałej części qubits (nazywanej rejestrem systemu).</span><span class="sxs-lookup"><span data-stu-id="95596-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="95596-131">Wszystkie inne wyniki pomiarów mogą jednak prowadzić do błędu.</span><span class="sxs-lookup"><span data-stu-id="95596-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="95596-132">Wzmocnienie amplitudy Oblivious umożliwia zwiększenie prawdopodobieństwa sukcesu tego pomiaru do $100 \\ % $ z powyższymi przyczynami.</span><span class="sxs-lookup"><span data-stu-id="95596-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="95596-133">Ponadto zwykłe wzmocnienie amplitudy odnosi się do przypadku, w którym rejestr systemu jest pusty.</span><span class="sxs-lookup"><span data-stu-id="95596-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="95596-134">Jest to dlatego Q# , że stosuje wzmocnienie amplitudy Oblivious jako podstawową podprocedurę wzmocnienia amplitudy.</span><span class="sxs-lookup"><span data-stu-id="95596-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="95596-135">Procedura ogólna ( `AmpAmpObliviousByReflectionPhases` ) ma dwa rejestry, które wywołujemy `ancillaRegister` i `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="95596-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="95596-136">Akceptuje również dwie Oracle w celu zaakceptowania niezbędnych odbić.</span><span class="sxs-lookup"><span data-stu-id="95596-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="95596-137">`ReflectionOracle`Działa tylko na `ancillaRegister` czas, w którym `ObliviousOracle` działają wspólnie dla obu rejestrów.</span><span class="sxs-lookup"><span data-stu-id="95596-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="95596-138">Dane wejściowe `ancillaRegister` muszą być zainicjowane do-1 eigenstate pierwszego operatora odbicia $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="95596-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="95596-139">Zazwyczaj firma Oracle przygotowuje stan w oparciu o podstawę obliczeniową $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="95596-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="95596-140">W naszej implementacji `ancillaRegister` składają się one z jednej qubit ( `flagQubit` ), która steruje `stateOracle` i resztą żądanego ancillasu.</span><span class="sxs-lookup"><span data-stu-id="95596-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="95596-141">`stateOracle`Jest stosowany, gdy `flagQubit` jest to $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="95596-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="95596-142">Jedna z nich może również dostarczać firmy Oracle `StateOracle` , a `ObliviousOracle` nie odbicia za pośrednictwem wywołania `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="95596-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="95596-143">Jak wspomniano, tradycyjne wzmocnienie amplitudy jest tylko szczególnym przypadkiem tych procedur `ObliviousOracle` , gdzie jest operatorem tożsamości i nie ma qubits systemu (tj. `systemRegister` jest pusty).</span><span class="sxs-lookup"><span data-stu-id="95596-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="95596-144">Jeśli chcesz uzyskać fazy dla częściowego odbicia (np. dla wyszukiwania Grover), funkcja `AmpAmpPhasesStandard` jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="95596-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="95596-145">Zapoznaj się z `DatabaseSearch.qs` przykładową implementacją algorytmu Grover.</span><span class="sxs-lookup"><span data-stu-id="95596-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="95596-146">W przypadku etapów obrotu pojedynczej qubit są powiązane fazy operatora odbicia, zgodnie z opisem w dokumencie przez [G.H. Low, I. L. Czuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="95596-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="95596-147">Stosowane fazy stałego punktu są szczegółowo opisane w [Yoder, niskiej i Czuang](https://arxiv.org/abs/1409.3305) wraz z fazami w [niskiej, Yoder i Czuang](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="95596-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="95596-148">W przypadku tła można zacząć od [wzmocnienia amplitudy standardowej](https://arxiv.org/abs/quant-ph/0005055) , a następnie przejść do wprowadzenia do [wzmocnienia amplitudy Oblivious](https://arxiv.org/abs/1312.1414) i wreszcie generalizacje prezentowane w [niskiej i Czuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="95596-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="95596-149">Przykładowa Prezentacja tego całego obszaru (w miarę odnosząca się do symulacji hamiltonian) została pobrana przez [Dominic jagody](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="95596-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="95596-150">Transformacja Fouriera Quantum</span><span class="sxs-lookup"><span data-stu-id="95596-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="95596-151">Transformacja Fouriera to podstawowe narzędzie do klasycznej analizy i jest równie ważne w przypadku obliczeń Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="95596-152">Ponadto wydajność *transformacji Fouriera* (QFT) w oparciu o liczbę, która jest możliwa na maszynie klasycznej, sprawia, że jest to jeden z pierwszych wybranych narzędzi do projektowania algorytmu Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="95596-153">Dzięki przybliżonej generalizacji QFT udostępniamy <xref:Microsoft.Quantum.Canon.ApproximateQft> operację, która pozwala na dalsze optymalizacje przez oczyszczanie rotacji, które nie są absolutnie niezbędne dla wymaganej dokładności algorytmu.</span><span class="sxs-lookup"><span data-stu-id="95596-153">As an approximate generalization of the QFT, we provide the <xref:Microsoft.Quantum.Canon.ApproximateQft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="95596-154">Przybliżony QFT wymaga operacji "dyadic $Z $-Rotation" <xref:Microsoft.Quantum.Intrinsic.RFrac> oraz <xref:Microsoft.Quantum.Intrinsic.H> operacji.</span><span class="sxs-lookup"><span data-stu-id="95596-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:Microsoft.Quantum.Intrinsic.RFrac> as well as the <xref:Microsoft.Quantum.Intrinsic.H> operation.</span></span>
<span data-ttu-id="95596-155">Założono, że dane wejściowe i wyjściowe są kodowane w big endian kodowania---to oznacza, że qubit z indeksem `0` jest zakodowana w lewym największej liczbie (najwyższa) bitowej binarnej liczbie całkowitej.</span><span class="sxs-lookup"><span data-stu-id="95596-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="95596-156">Jest to wyrównane z [notacją KET](xref:microsoft.quantum.concepts.dirac), ponieważ rejestr trzech qubits w stanie $ \ket {100} $ odpowiada $q _0 $ jest w stanie $ \ket {1} $, natomiast $q _1 $ i $q _2 $ są w stanie $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="95596-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="95596-157">Parametr przybliżenia $a $ określa poziom oczyszczenia $Z $-rotations, czyli $a \In [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="95596-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="95596-158">W tym przypadku wszystkie $Z $-rotations $2 \ pi/2 ^ k $, gdzie $k > a $ są usuwane z obwodu usługi QFT.</span><span class="sxs-lookup"><span data-stu-id="95596-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="95596-159">Wiadomo, że dla $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="95596-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="95596-160">Jedna z nich może być powiązana $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="95596-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="95596-161">W tym miejscu $ \\ | \cdot \\ | $ jest normą operatora, która w tym przypadku jest pierwiastek kwadratowy największego [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) z $ (\operatorname{QFT}-\operatorname{AQFT}) (\operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="95596-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="95596-162">Arytmetyczny</span><span class="sxs-lookup"><span data-stu-id="95596-162">Arithmetic</span></span> ##

<span data-ttu-id="95596-163">Podobnie jak arytmetyczne odgrywają centralną rolę w środowisku klasycznym, jest również niezbędny w przypadku przetwarzania Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="95596-164">Algorytmy, takie jak algorytm refaktoryzacji skró, metody symulacji Quantum i wiele algorytmów oracular polegają na spójnych operacjach arytmetycznych.</span><span class="sxs-lookup"><span data-stu-id="95596-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="95596-165">Większość podejścia do operacji arytmetycznych na podstawie obwodów z dołączaniem Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="95596-166">Najprostszym obiektem dodającym jest klasyczne dane wejściowe $b $ i dodaje wartość do stanu Quantum przechowującego liczbę całkowitą $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="95596-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="95596-167">Matematycznie, Metoda dodająca (która oznacza $ \operatorname{Add} (b) $ dla klasycznego wejścia $b $) ma właściwość, która</span><span class="sxs-lookup"><span data-stu-id="95596-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="95596-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="95596-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="95596-169">$ $ Ten podstawowy obwód do dołączania jest większy niż dodający się do dołączenia.</span><span class="sxs-lookup"><span data-stu-id="95596-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="95596-170">Można go przekonwertować na obiekt dodający, który ma dwa dane wejściowe Quantum za pośrednictwem $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ przy użyciu $n $ kontrolowane aplikacje do dodających formularzy \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left (\operatorname{Add} (1) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} dla $n $-bitowych liczb całkowitych $a $ i $b $ i Dodawanie modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="95596-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="95596-171">Odwołaj tę notację $ \Lambda \_ x (A) $ odwołuje się do każdej operacji $A $, do kontrolowanej wersji tej operacji za pomocą qubit $x $ AS.</span><span class="sxs-lookup"><span data-stu-id="95596-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="95596-172">Podobnie kontrolowana w sposób klasyczny sposób mnożenia (modułowy formularz, który jest niezbędny dla algorytmu refaktoryzacji skró) można wykonać przy użyciu podobnej serii kontrolowanych dodatków: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left (\operatorname{Add} (2 ^ 0 a) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="95596-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="95596-173">\end{align} istnieje subtlety z mnożeniem na komputerach z systemem Quantum, które można zauważyć z definicji $ \operatorname{Mult} $ powyżej.</span><span class="sxs-lookup"><span data-stu-id="95596-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="95596-174">W przeciwieństwie do dodania, wersja Quantum tego obwodu przechowuje produkt danych wejściowych w rejestrze pomocniczym, a nie w rejestrze wejściowym.</span><span class="sxs-lookup"><span data-stu-id="95596-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="95596-175">W tym przykładzie rejestr jest inicjowany z wartością $b $, ale zazwyczaj zacznie utrzymywać wartość zero.</span><span class="sxs-lookup"><span data-stu-id="95596-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="95596-176">Jest to niezbędny w przypadku, gdy w ogóle nie istnieje mnożenia dla ogólnych $a $ i $x $.</span><span class="sxs-lookup"><span data-stu-id="95596-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="95596-177">Ponieważ wszystkie operacje Quantum, Save pomiary, są odwracalnie, musimy zachować wystarczającą ilość informacji, aby odwrócić mnożenie.</span><span class="sxs-lookup"><span data-stu-id="95596-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="95596-178">Z tego powodu wynik jest przechowywany w oddzielnej tablicy.</span><span class="sxs-lookup"><span data-stu-id="95596-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="95596-179">Ta część zapisywania danych wyjściowych operacji nieodwracalnych, takich jak mnożenie, w osobnym rejestrze nosi nazwę "Bennett lew" po Charlie Bennett i jest podstawowym narzędziem do przetwarzania w trybie odwracalnym i Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="95596-180">Zaproponowano wiele obwodów Quantum do dodania, a każda z nich analizuje różne kompromisy pod względem liczby qubits (miejsca) i liczby wymaganych operacji na bramie (czas).</span><span class="sxs-lookup"><span data-stu-id="95596-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="95596-181">Przeglądamy dwa bardziej wydajne elementy dodające o dużej ilości miejsca, znane jako Draper dodające i Beauregard.</span><span class="sxs-lookup"><span data-stu-id="95596-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="95596-182">Draper</span><span class="sxs-lookup"><span data-stu-id="95596-182">Draper Adder</span></span> ###

<span data-ttu-id="95596-183">Draper dodający jest raczej jednym z najbardziej eleganckich elementów Quantum, ponieważ bezpośrednio wywołuje właściwości Quantum do wykonania.</span><span class="sxs-lookup"><span data-stu-id="95596-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="95596-184">Wgląd za Draper dodający to, że transformacja Fouriera może służyć do translacji przesunięcia fazy na bit Shift.</span><span class="sxs-lookup"><span data-stu-id="95596-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="95596-185">Następnie następuje zastosowanie transformacji Fouriera, zastosowanie odpowiedniej fazy zmiany, a następnie cofnięcie przekształcenia Fouriera można zaimplementować.</span><span class="sxs-lookup"><span data-stu-id="95596-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="95596-186">W przeciwieństwie do wielu innych proponowanych dodających, funkcja Draper Explicit jawnie używa efektów Quantum wprowadzonych przez transformację Quantum Fouriera.</span><span class="sxs-lookup"><span data-stu-id="95596-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="95596-187">Nie ma naturalnego klasycznego odpowiednika.</span><span class="sxs-lookup"><span data-stu-id="95596-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="95596-188">Poniżej przedstawiono określone kroki Draper.</span><span class="sxs-lookup"><span data-stu-id="95596-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="95596-189">Załóżmy, że masz dwa $n $-bitowe qubit rejestruje liczby całkowite $a $ i $b $, dla wszystkich $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="95596-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="95596-190">$ $ Jeśli definiujemy $ $ \ket{\phi \_ k (a)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right), $ $ następnie po niektórych algebry można zobaczyć, że $ $ \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 (a)} \otimes \cdots \otimes \ket{\phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="95596-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="95596-191">$ $ Ścieżka do wykonania dodanego obiektu zostanie wyczyszczona po zaobserwowaniu, że suma danych wejściowych może być zapisywana jako $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\phi \_ 1 (a + b)} \otimes \cdots \otimes \ket{\phi \_ n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="95596-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="95596-192">$ $ Liczby całkowite $b $ i $a $ można następnie dodać przez przeprowadzenie rotacji kontrolowanej fazy na każdym z qubits w dekompozycji przy użyciu bitów $b $ as Controls.</span><span class="sxs-lookup"><span data-stu-id="95596-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="95596-193">To rozwinięcie może być dodatkowo uproszczone przez zanotowanie, że dla dowolnej liczby całkowitej $j $ i liczby rzeczywistej $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="95596-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="95596-194">Wynika to z faktu, że w przypadku rotacji $360 ^ {\circ} $ stopni ($ 2 \ pi $ RADIANS) w okręgu zostanie precyzyjnie dokończyć pracę.</span><span class="sxs-lookup"><span data-stu-id="95596-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="95596-195">Jedyną istotną częścią $x $ dla $e ^ {i2\pi x} $ jest w związku z tym ułamkowa część $x $.</span><span class="sxs-lookup"><span data-stu-id="95596-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="95596-196">W przypadku, gdy mamy rozwinięcie binarne formularza $x = t +0. x \_ 0x \_ 2 \ ldots x \_ n $ następnie $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1})} $ i w związku z tym $ $ \ket{\phi \_ k (a + b)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi [a/2 ^ k +0). b \_ k\ldots b \_ 1]} \ket {1} \right). $ $ oznacza to, że jeśli wykonujemy Dodawanie przez zwiększenie każdego ze współczynników dwuetapowych w rozwinięciu przekształcenia fouriera $ \ket{a} $, wówczas liczba obrotów zmniejszy się do $k $ zmniejsza.</span><span class="sxs-lookup"><span data-stu-id="95596-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="95596-197">Znacznie zmniejsza liczbę bram Quantum wymaganych w dodającej.</span><span class="sxs-lookup"><span data-stu-id="95596-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="95596-198">Notujemy transformację Fouriera, Dodawanie faz i odwrotne kroki transformacji Fouriera, które składają się na Draper dodające jako $ \operatorname{QFT} ^ {-1} \left (\Phi \\ \! \operatorname{Add}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="95596-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="95596-199">Poniżej można zobaczyć obwód Quantum, który używa tego uproszczenia do implementacji całego procesu.</span><span class="sxs-lookup"><span data-stu-id="95596-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Drapere, które są wyświetlane jako diagram obwodu](~/media/draper.svg)

<span data-ttu-id="95596-201">Każda kontrolowana Brama $e ^ {I2 \ pi/k} $ w obwodzie odwołuje się do bramy sterowanej fazy.</span><span class="sxs-lookup"><span data-stu-id="95596-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="95596-202">Takie bramy mają właściwość, która znajduje się na parze qubits, w której działają, $ \ket {00} \mapsto \ket {00} $, ale $ \ket {11} \mapsto e ^ {I2 \ pi/k} \ KET {11} $.</span><span class="sxs-lookup"><span data-stu-id="95596-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="95596-203">Obwód ten pozwala nam wykonać Dodawanie przy użyciu żadnych dodatkowych qubits poza tymi, które są konieczne do przechowywania danych wejściowych i wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="95596-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="95596-204">Beauregard</span><span class="sxs-lookup"><span data-stu-id="95596-204">Beauregard Adder</span></span> ###

<span data-ttu-id="95596-205">Beauregard dodający jest modularnym modułem dodający, który korzysta z dodającego Draper, aby wykonać Dodawanie modulo $N $ dla dowolnej wartości dodatniej liczby całkowitej $N $.</span><span class="sxs-lookup"><span data-stu-id="95596-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="95596-206">Znaczenie modularnych elementów dodających, takich jak Beauregard, jest w dużym stopniu od ich użycia w ramach modularnego etapu potęgowania w algorytmie skró.</span><span class="sxs-lookup"><span data-stu-id="95596-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="95596-207">Modularna funkcja dodająca Quantum ma następujące działania dla danych wejściowych Quantum $ \ket{b} $ i klasyczne dane wejściowe $a $, gdzie $a $ i $b $ są przypadane jako liczby całkowite mod $N $, co oznacza, że znajdują się w interwale $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="95596-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="95596-208">$ $ \ket{b}\rightarrow \ket{b + a \Text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N \\ \\ \ket{b + a-N}, & (b + a) \ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="95596-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="95596-209">Beauregard dodając używa dodającego Draper lub dokładniej $ \phi \\ \! \operatorname{Add} $, aby dodać $a $ i $b $ w fazie.</span><span class="sxs-lookup"><span data-stu-id="95596-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="95596-210">Następnie używa tej samej operacji, aby określić, czy $a + b <N $ przez odjęcie $N $ i testowanie, jeśli $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="95596-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="95596-211">Obwód przechowuje te informacje w pomocniczej qubit, a następnie dodaje $N $ back a, jeśli $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="95596-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="95596-212">Następnie zwalnia ten bit pomocniczy (ten krok jest niezbędny, aby zapewnić, że po wywołaniu funkcji dodającej Ancilla można cofnąć alokację).</span><span class="sxs-lookup"><span data-stu-id="95596-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="95596-213">Poniżej przedstawiono obwód dla Beauregard.</span><span class="sxs-lookup"><span data-stu-id="95596-213">The circuit for the Beauregard adder is given below.</span></span>

![Beauregarde, które są wyświetlane jako diagram obwodu](~/media/beau.svg)

<span data-ttu-id="95596-215">W tym miejscu Brama $ \Phi \\ \! \operatorname{Add} $ przyjmuje ten sam formularz co $ \Phi \\ \! \operatorname{Add} $, z wyjątkiem tego, że w tym kontekście dane wejściowe są klasyczne, a nie Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="95596-216">Dzięki temu kontrolowane fazy w $ \Phi \\ \! \operatorname{Add} $ mają być zastępowane bramami faz, które następnie można kompilować w mniejszej liczbie operacji, aby zmniejszyć liczbę qubits i liczbę bram potrzebnych do dodającego.</span><span class="sxs-lookup"><span data-stu-id="95596-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="95596-217">Aby uzyskać więcej informacji, zapoznaj się z tematem [M. Roetteler, th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) i [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="95596-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="95596-218">Szacowanie fazy kwantowej</span><span class="sxs-lookup"><span data-stu-id="95596-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="95596-219">Jednym z szczególnie ważnych zastosowań transformacji Fouriera Quantum jest poznanie eigenvalues operatorów jednostkowych, problemu znanego jako *oszacowanie fazy* .</span><span class="sxs-lookup"><span data-stu-id="95596-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation* .</span></span>
<span data-ttu-id="95596-220">Rozważ użycie jednostek $U $ i State $ \ket{\phi} $, tak że $ \ket{\phi} $ to eigenstate z $U $ z nieznanym eigenvalue $ \phi $, \begin{Equation} U\ket {\ Fi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="95596-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="95596-221">\end{Equation} Jeśli mamy dostęp do $U $ jako Oracle, możemy poznać fazę $ \phi $, wykorzystując, że $Z $ rotacje zastosowane do obiektu docelowego kontrolowanej operacji propagują do formantu.</span><span class="sxs-lookup"><span data-stu-id="95596-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="95596-222">Załóżmy, że $V $ jest kontrolowanym zastosowaniem $U $, takich jak \begin{align} V (\ket {0} \otimes \ket{\phi}) & = \ket {0} \otimes \ket{\phi} \\ \\ \textrm{i} V (\ket {1} \otimes \ket{\phi}) & = e ^ {i \phi} {1} \ket \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="95596-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="95596-223">\end{align} następnie, według liniowości, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket {0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket {1} \otimes \ket{\phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="95596-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="95596-224">\end{align} możemy zbierać warunki, aby znaleźć \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket {0} + e ^ {i \phi} \ket {1} } {\sqrt {2} } \otimes \ket{\phi} \\ \\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi}, \end{align} gdzie $R _1 $ jest jednostką stosowaną przez <xref:Microsoft.Quantum.Intrinsic.R1> operację.</span><span class="sxs-lookup"><span data-stu-id="95596-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:Microsoft.Quantum.Intrinsic.R1> operation.</span></span>
<span data-ttu-id="95596-225">Inaczej mówiąc, efekt zastosowania $V $ jest dokładnie taki sam jak zastosowanie $R _1 $ z nieznanym kątem, nawet jeśli mamy dostęp tylko do $V $ jako Oracle.</span><span class="sxs-lookup"><span data-stu-id="95596-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="95596-226">W związku z tym w pozostałej części tej dyskusji będziemy omawiać oszacowania fazy pod względem $R _1 (\phi) $, który implementuje się przy użyciu tak zwanej *fazy KickBack* .</span><span class="sxs-lookup"><span data-stu-id="95596-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback* .</span></span>

<span data-ttu-id="95596-227">Ponieważ kontrolka i rejestr docelowy pozostają untangled po tym procesie, możemy ponownie użyć $ \ket{\phi} $ jako elementu docelowego kontrolowanej aplikacji $U ^ $2, aby przygotować drugi formant qubit w stanie $R _1 (2 \phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="95596-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="95596-228">W ten sposób możemy uzyskać rejestr w formie \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket {0} + \exp (i 2 ^ {j} \phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}, gdzie $n $ to liczba wymaganych przez nas elementów dokładności, i gdzie użyto $ {} \propto {} $, aby wskazać, że został pominięty współczynnik normalizacji $1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="95596-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="95596-229">Jeśli przyjęto założenie, że $ \phi = 2 \pi p/2 ^ k $ dla liczby całkowitej $p $, rozpoznawamy to jako $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, gdzie $p _j $ to $j ^ {\textrm{th}} $ bit $2 \pi \phi $.</span><span class="sxs-lookup"><span data-stu-id="95596-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="95596-230">W związku z zastosowaniem sąsiedniej transformacji Fouriera Quantum, firma Microsoft uzyskuje reprezentację binarną fazy zakodowanej jako stan Quantum.</span><span class="sxs-lookup"><span data-stu-id="95596-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="95596-231">W programie Q# jest to implementowane przez <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> operację, która wymaga <xref:Microsoft.Quantum.Oracles.DiscreteOracle> wdrożenia aplikacji $U ^ m $ jako funkcji dodatnich liczb całkowitych $m $.</span><span class="sxs-lookup"><span data-stu-id="95596-231">In Q#, this is implemented by the <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> operation, which takes a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
