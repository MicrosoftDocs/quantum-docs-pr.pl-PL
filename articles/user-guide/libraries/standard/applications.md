---
title: 'Aplikacje w :::no-loc(Q#)::: bibliotekach standardowych'
description: Dowiedz się więcej o dwóch podstawowych aplikacjach związanych z przetwarzaniem Quantum — hamiltonian symulacji i algorytmem wyszukiwania skró.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 5a29dcc74c638cb8ecbeb1f924d0e50d40d19f66
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692174"
---
# <a name="applications"></a><span data-ttu-id="0736d-103">Aplikacje</span><span class="sxs-lookup"><span data-stu-id="0736d-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="0736d-104">Symulacja Hamiltona</span><span class="sxs-lookup"><span data-stu-id="0736d-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="0736d-105">Symulacja systemów Quantum jest jednym z najbardziej atrakcyjnych zastosowań obliczeń Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="0736d-106">Na klasycznym komputerze trudność symulowania Mechanics Quantum, ogólnie rzecz biorąc, Skaluje wymiar $N $ swojej reprezentacji wektora stanu.</span><span class="sxs-lookup"><span data-stu-id="0736d-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="0736d-107">Ponieważ ta reprezentacja rośnie wykładniczo z liczbą $n $ qubits $N = 2 ^ n $, cecha znana także jako [ponosi](xref:microsoft.quantum.concepts.multiple-qubits)się do naliczania wartości, Symulacja Quantum dla klasycznego sprzętu jest niezależna.</span><span class="sxs-lookup"><span data-stu-id="0736d-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="0736d-108">Jednak sytuacja może być bardzo różna w przypadku sprzętu Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="0736d-109">Najbardziej typowa zmiana symulacji Quantum jest nazywana niezależnym czasem problemem symulacji hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="0736d-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="0736d-110">Istnieje jednak jeden z opisów systemu, $H $, który jest matrycą hermitian, i pewien początkowy stan Quantum $ \ket{\psi (0)} $, który jest zakodowany w sposób niezależny od $n $ qubits na komputerze Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="0736d-111">Stany Quantum w systemach zamkniętych rozwijają się w ramach równania Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ celem jest zaimplementowanie operatora ewolucji czasu jednostkowego $U (t) = e ^ {-iHt} $ w niestałym czasie $t $, gdzie $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ rozwiązuje równanie Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="0736d-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="0736d-112">Analogicznie, zależny od czasu problem symulacji hamiltonian rozwiązuje takie samo równanie, ale z $H (t) $ teraz funkcją czasu.</span><span class="sxs-lookup"><span data-stu-id="0736d-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="0736d-113">Symulacja hamiltonian jest głównym składnikiem wielu innych problemów z symulacją usługi Quantum, a rozwiązaniami związanymi z symulacją hamiltonian są algorytmy opisujące sekwencję pierwotnych bram Quantum, które umożliwiają wyznaczanie przybliżonych jednostek $ \tilde{U} $ z błędem $ \\ | \tilde{U}-U (t) \\ | \le \epsilon $ w [normie widmowej](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="0736d-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="0736d-114">Złożoność tych algorytmów jest bardzo silnie zależała od tego, w jaki sposób opis hamiltonian zainteresowania jest dostępny dla komputera Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="0736d-115">Na przykład w najgorszym przypadku, jeśli $H $ działające na $n $ qubits zostały podane jako lista $2 ^ n \times 2 ^ n $ Numbers, po jednym dla każdego elementu macierzy po prostu odczytywanie danych będzie wymagało wykładniczego czasu.</span><span class="sxs-lookup"><span data-stu-id="0736d-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="0736d-116">W najlepszym przypadku jedna z nich może przyjąć dostęp do wielodostępnego modułu, który $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ w sposób nieprosty rozwiązuje problem.</span><span class="sxs-lookup"><span data-stu-id="0736d-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="0736d-117">Żaden z tych modeli danych wejściowych nie jest szczególnie interesujący — nie jest to dawne podejście, które nie jest lepiej niż w przypadku klasycznych metod, a drugie, jak czarne pole ukrywa złożoność bramy pierwotnej, co może być wykładnicze w liczbie qubits.</span><span class="sxs-lookup"><span data-stu-id="0736d-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="0736d-118">Opisy Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="0736d-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="0736d-119">W związku z tym wymagane są dodatkowe założenia formatu danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="0736d-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="0736d-120">Należy zachować równowagę między modelami wejściowymi, które są wystarczająco opisowe, aby obejmowały interesujące Hamiltonians, takie jak te dla realistycznych systemów fizycznych lub interesujących problemów obliczeniowych, oraz modeli wejściowych, które są wystarczająco restrykcyjne w celu wydajnego zaimplementowania na komputerze Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="0736d-121">Różne nieuproszczone modele wejściowe mogą znajdować się w literaturze i mieszczą się w zakresie od Quantum do klasycznej.</span><span class="sxs-lookup"><span data-stu-id="0736d-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="0736d-122">Jako przykłady modeli wejściowych Quantum, [oparta na przykładach symulacja Hamiltoniana](http://www.nature.com/articles/s41534-017-0013-7) zakłada dostęp do operacji Quantum, które tworzą kopie macierzy gęstości $ \rho $, które są przeznaczone do hamiltonian $H $.</span><span class="sxs-lookup"><span data-stu-id="0736d-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="0736d-123">W [modelu dostępu](https://arxiv.org/abs/1202.5822) jednokierunkowego, Załóżmy, że hamiltonian w sumie unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $, gdzie $a \_ j>$0 są współczynnikiem, a $ \hat{U} \_ j $ to unitaries.</span><span class="sxs-lookup"><span data-stu-id="0736d-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="0736d-124">Następnie zakłada się, że jeden z nich ma dostęp z czerni do jednostki Oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $, który wybiera żądany $ \hat{U} \_ j $, i Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ sum ^ {d-1} \_ {k = 0} \Alpha \_ j} \ket{j} $, które tworzą kodowanie stanu Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="0736d-125">W przypadku [symulacji hamiltonian rozrzedzonej](https://arxiv.org/abs/quant-ph/0301023), jedna zakłada, że hamiltonian jest macierzą rozrzedzoną, tylko $d = \mathcal{O} (\Text{polylog} (N)) $ niezerową elementu w każdym wierszu.</span><span class="sxs-lookup"><span data-stu-id="0736d-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="0736d-126">Ponadto jeden z nich zakłada istnienie wydajnych obwodów Quantum, które wyprowadzają lokalizację tych elementów innych niż zero, a także ich wartości.</span><span class="sxs-lookup"><span data-stu-id="0736d-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="0736d-127">Złożoność [algorytmów symulacji hamiltonian](xref:microsoft.quantum.more-information) jest oceniana w postaci liczby zapytań do tych czarnych pól, a złożoność bramy pierwotnej zależy znacznie od trudności związanych z wdrażaniem tych czerni.</span><span class="sxs-lookup"><span data-stu-id="0736d-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="0736d-128">Notacja Big-O jest często używana do opisywania stopnia złożoności algorytmów.</span><span class="sxs-lookup"><span data-stu-id="0736d-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="0736d-129">Podaną dwie funkcje prawdziwe $f, g $, wyrażenie $g (x) = \mathcal{O} (f (x)) $ oznacza, że istnieje bezwzględna dodatnia stała $x \_ 0, c>$0, taka jak $g (x) \le c f (x) $ dla wszystkich $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="0736d-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="0736d-130">W większości praktycznych aplikacji, które mają być implementowane na komputerze z systemem Quantum, te czarne pola muszą być efektywnie zaimplementowane, czyli z $ \mathcal{O} (\Text{polylog} (N)) $ pierwotnymi bramami Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="0736d-131">Bardziej silnie simulable Hamiltonians musi mieć wystarczająco rozrzedzony opis klasyczny.</span><span class="sxs-lookup"><span data-stu-id="0736d-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="0736d-132">W jednym z takich rodzajów, zakłada się, że hamiltonian dekomponowa w sumie hermitian części $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="0736d-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="0736d-133">\end{align} $ $ Ponadto zakłada się, że każda część, hamiltonian $H \_ j $, jest łatwa do symulowania.</span><span class="sxs-lookup"><span data-stu-id="0736d-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="0736d-134">Oznacza to, że jednostka $e ^ {-iH \_ j t} $ dla dowolnej godziny $t $ może być implementowana dokładnie przy użyciu $ \mathcal{O} (1) $ pierwotnych bram Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="0736d-135">Dotyczy to na przykład sytuacji, w której każda $H \_ j $ są lokalnymi operatorami Pauli, co oznacza, że są to produkty dwuczęściowe klasy $ \mathcal{O} (1) $ operatory nietożsamości Pauli, które działają w pobliżu blisko qubits.</span><span class="sxs-lookup"><span data-stu-id="0736d-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="0736d-136">Ten model jest szczególnie stosowany w przypadku systemów fizycznych z powiązanymi i lokalnymi interakcjami, ponieważ liczba warunków to $d = \mathcal{O} (\Text{polylog} (N)) $, i może być jasno zapisywana, tj. opisana w sposób klasyczny, w czasie wielomianu.</span><span class="sxs-lookup"><span data-stu-id="0736d-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="0736d-137">Hamiltonians, które dzielą się na sumę części, można opisać przy użyciu biblioteki dynamicznej reprezentacji generatora.</span><span class="sxs-lookup"><span data-stu-id="0736d-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="0736d-138">Aby uzyskać więcej informacji, zobacz sekcję reprezentacja generatora dynamicznego w temacie [struktury danych](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="0736d-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="0736d-139">Algorytmy symulacji</span><span class="sxs-lookup"><span data-stu-id="0736d-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="0736d-140">Algorytm symulacji Quantum konwertuje dany opis hamiltonian na sekwencję pierwotnych bram Quantum, które, jako całość, przybliżony czas rozwoju według wspomnianych hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="0736d-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="0736d-141">W specjalnym przypadku, gdy hamiltonian dekomponowa w sumie części hermitian, dekompozycja Trotter-Suzuki jest szczególnie prostym i intuicyjnym algorytmem do symulowania Hamiltonians, które rozkładają się na sumę składników hermitian.</span><span class="sxs-lookup"><span data-stu-id="0736d-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="0736d-142">Na przykład, Integrator pierwszej kolejności tej rodziny przybliża $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ przy użyciu produktu $r d $ terms.</span><span class="sxs-lookup"><span data-stu-id="0736d-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="0736d-143">W przykładach są omówione aplikacje algorytmu symulacji Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="0736d-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="0736d-144">W przypadku modelu Ising używającego tylko operacji wewnętrznych dostarczonych przez każdą maszynę docelową należy zapoznać się z [przykładem **SimpleIsing**](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="0736d-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="0736d-145">Aby uzyskać Ising model przy użyciu struktury kontrolki biblioteki Trotter-Suzuki, zobacz przykład [ **IsingTrotter**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="0736d-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="0736d-146">W przypadku wodoru molekularnego przy użyciu struktury kontrolki biblioteki Trotter-Suzuki, zobacz [przykład **symulacji H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="0736d-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="0736d-147">W wielu przypadkach chcemy zaimplementować algorytm symulacji, ale nie interesuje Cię szczegółowe informacje o jego implementacji.</span><span class="sxs-lookup"><span data-stu-id="0736d-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="0736d-148">Na przykład, Integrator drugiej kolejności przybliża $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/2R} e ^ {-IH \_ 1 t/2R} \cdots e ^ {-IH \_ {d-1} t/2R} ^ {-IH \_ {d-1} t/2R} \cdots e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ przy użyciu produktu $2RD $ terms.</span><span class="sxs-lookup"><span data-stu-id="0736d-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="0736d-149">Większe zamówienia obejmują jeszcze więcej terminów i zoptymalizowane warianty mogą wymagać bardzo nieuproszczonych porządków wykładniczych.</span><span class="sxs-lookup"><span data-stu-id="0736d-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="0736d-150">Inne zaawansowane algorytmy mogą również polegać na wykorzystaniu Ancilla qubits w pośrednich krokach.</span><span class="sxs-lookup"><span data-stu-id="0736d-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="0736d-151">Dlatego algorytmy symulacji pakietów w formacie Canon jako typ zdefiniowany przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="0736d-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="0736d-152">Pierwszy parametr `Double` to czas symulacji, drugi parametr `EvolutionGenerator` , objęty sekcją reprezentacja generatora dynamicznego [struktur danych](xref:microsoft.quantum.libraries.data-structures), to klasyczny opis niezależny od czasu hamiltonian zapakowany z instrukcjami dotyczącymi sposobu symulowania każdego terminu w hamiltonian przez obwód Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="0736d-153">Typy tego formularza przybliżą operacje jednostkowe $e ^ {-iHt} $ w trzecim parametrze `Qubit[]` , który jest rejestrem przechowującym stan Quantum symulowanego systemu.</span><span class="sxs-lookup"><span data-stu-id="0736d-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="0736d-154">Podobnie jak w przypadku przypadków zależnych od czasu, definiujemy typ zdefiniowany przez użytkownika z `EvolutionSchedule` typem, który jest klasyczny opis hamiltonian zależnych od czasu.</span><span class="sxs-lookup"><span data-stu-id="0736d-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="0736d-155">Przykładowo dekompozycja Trotter-Suzuki może być wywoływana przy użyciu następujących funkcji firmy Canon z parametrami `trotterStepSize` modyfikującymi czas trwania symulacji w każdej wykładniczej i `trotterOrder` dla kolejności wybranego integratora.</span><span class="sxs-lookup"><span data-stu-id="0736d-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="0736d-156">Aplikacje biblioteki symulacji zostały omówione w przykładach.</span><span class="sxs-lookup"><span data-stu-id="0736d-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="0736d-157">Aby oszacować fazę w modelu Ising przy użyciu `SimulationAlgorithm` , zobacz [przykład **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="0736d-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="0736d-158">Na potrzeby przygotowania stanu adiabatic w modelu Ising przy użyciu polecenia `TimeDependentSimulationAlgorithm` Zobacz przykład [ **AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="0736d-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="0736d-159">Adiabatic przygotowanie stanu & szacowania fazy</span><span class="sxs-lookup"><span data-stu-id="0736d-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="0736d-160">Jedną z typowych zastosowań symulacji hamiltonian jest adiabatice przygotowanie stanu.</span><span class="sxs-lookup"><span data-stu-id="0736d-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="0736d-161">W tym miejscu udostępniono dwa Hamiltonians $H \_ {\Text{Start}} $ i $H \_ {\Text{End}} $ oraz stan Quantum $ \ket{\psi (0)} $, który jest stanem uziemienia $H Start hamiltonian \_ {\Text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="0736d-162">Zwykle $H \_ {\Text{Start}} $ jest wybierana w taki sposób, że $ \ket{\psi (0)} $ można łatwo przygotować ze stanu podstawy obliczeniowej $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="0736d-163">Przez interpolację między tymi Hamiltoniansami w przypadku problemów symulacji zależnych od czasu jest to możliwe, aby zakończyć działanie o wysokim prawdopodobieństwie w stanie ziemi końcowego hamiltonian $H \_ {\Text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="0736d-164">Mimo że przygotowywanie dobrych przybliżeń do Stanów naziemnych hamiltonian może być w ten sposób podejmowane przy użyciu zależnych od czasu algorytmów symulacji hamiltonian jako procedury podrzędnej, inne podejścia koncepcyjnego, takie jak odmiana Quantum eigensolver, są możliwe.</span><span class="sxs-lookup"><span data-stu-id="0736d-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="0736d-165">Jeszcze inna aplikacja, która jest powszechnie stosowana w chemii Quantum, szacuje energię stanu ziemi Hamiltonians reprezentującą pośrednie etapy reakcji chemicznej.</span><span class="sxs-lookup"><span data-stu-id="0736d-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="0736d-166">Taki schemat może na przykład polegać na przygotowaniu stanu adiabatic w celu utworzenia stanu ziemi, a następnie dołączeniu symulacji niezależnej od czasu hamiltonian jako procedury podrzędnej w celu wyodrębnienia tej energii z pewnymi błędami i prawdopodobieństwem sukcesu.</span><span class="sxs-lookup"><span data-stu-id="0736d-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="0736d-167">Abstrakcyjne algorytmy symulacji jako typy zdefiniowane przez użytkownika `SimulationAlgorithm` i `TimeDependentSimulationAlgorithm` pozwalają nam dołączać funkcje do bardziej zaawansowanych algorytmów Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="0736d-168">W tym celu należy wykonać te same czynności dla tych często używanych podprocedur.</span><span class="sxs-lookup"><span data-stu-id="0736d-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="0736d-169">Dlatego definiujemy wygodną funkcję</span><span class="sxs-lookup"><span data-stu-id="0736d-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="0736d-170">Spowoduje to zwrócenie operacji jednostkowej implementującej wszystkie kroki przygotowania stanu adiabatic.</span><span class="sxs-lookup"><span data-stu-id="0736d-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="0736d-171">Pierwszy parametr `interpolatedTime` określa czas, przez który liniowo interpoluje się między początkową hamiltonian opisaną przez drugi parametr `evolutionGeneratorStart` i końcowy hamiltonian opisany przez trzeci parametr `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="0736d-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="0736d-172">Czwarty parametr `timeDependentSimulationAlgorithm` polega na tym, że jeden z nich tworzy algorytm symulacji.</span><span class="sxs-lookup"><span data-stu-id="0736d-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="0736d-173">Należy pamiętać, że jeśli `interpolatedTime` jest wystarczająco długi, początkowy stan uziemienia pozostaje stan chwilowy hamiltonian przez cały czas trwania symulacji zależnej od czasu i w związku z tym kończy się w stanie uziemienia hamiltonian końcowego.</span><span class="sxs-lookup"><span data-stu-id="0736d-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="0736d-174">Definiujemy również przydatną operację, która automatycznie wykonuje wszystkie kroki typowego eksperymentu z chemią Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="0736d-175">Na przykład mamy następujące elementy, które zwracają oszacowanie energii stanu utworzonego przez przygotowanie adiabatic stanu:</span><span class="sxs-lookup"><span data-stu-id="0736d-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="0736d-176">`nQubits` jest liczbą qubits używaną do kodowania początkowego stanu Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="0736d-177">`statePrepUnitary` przygotowuje stan rozpoczęcia od podstaw obliczeniowej $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="0736d-178">`adiabaticUnitary` jest operacją jednostkową implementującą przygotowanie stanu adiabatic, na przykład wytwarzany przez  `InterpolatedEvolution` funkcję.</span><span class="sxs-lookup"><span data-stu-id="0736d-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="0736d-179">`qpeUnitary` jest operacją jednostkową, która jest używana do wykonywania oszacowania fazy na wynikającym stanie Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="0736d-180">`phaseEstAlgorithm` to nasz wybór algorytmu szacowania fazy.</span><span class="sxs-lookup"><span data-stu-id="0736d-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="0736d-181">Aplikacje adiabaticego stanu są omówione w przykładach.</span><span class="sxs-lookup"><span data-stu-id="0736d-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="0736d-182">W przypadku modelu Ising przy użyciu ręcznej implementacji przygotowania stanu adiabatic przy użyciu `AdiabaticEvolution` funkcji należy zapoznać się z [przykładem **AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="0736d-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="0736d-183">Aby oszacować fazę i przygotowanie stanu adiabatic w modelu Ising, zobacz [przykład **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="0736d-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="0736d-184">[Symulacja wodoru wodór](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) jest ciekawym i zwięzłym przykładem.</span><span class="sxs-lookup"><span data-stu-id="0736d-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="0736d-185">Model i wyniki eksperymentalne zgłoszone w [O'Malley et. Al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="0736d-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="0736d-186">wymaga tylko macierzy Pauli i przyjmuje postać $ \hat H = g \_ {0} I \_ 0I \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {t \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {X \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="0736d-187">Jest to efektywne hamiltonian tylko 2 qubits, gdzie stałe $g $ są obliczane z odległości $R $ między dwoma atomami wodoru.</span><span class="sxs-lookup"><span data-stu-id="0736d-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="0736d-188">Korzystając z funkcji firmy Canon, Paul jest konwertowany na unitaries, a następnie rozwijany w krótkim okresie czasu przy użyciu dekompozycji Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="0736d-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="0736d-189">Dobre przybliżenie do $H stanu ziemi $ uziemienia można utworzyć bez użycia przygotowania stanu adiabaticu, dlatego energia stanu ziemi może być znaleziona bezpośrednio przez wykorzystanie oszacowania fazy z firmy Canon.</span><span class="sxs-lookup"><span data-stu-id="0736d-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="0736d-190">Algorytm Shora</span><span class="sxs-lookup"><span data-stu-id="0736d-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="0736d-191">Algorytm skró pozostaje jednym z najbardziej znaczących zmian w zakresie przetwarzania w modelu Quantum, ponieważ wykazał, że komputery z systemem Quantum mogą być używane do rozwiązywania ważnych, obecnie w sposób klasycznych problemów z problemami.</span><span class="sxs-lookup"><span data-stu-id="0736d-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="0736d-192">Algorytm skró zapewnia szybki sposób wykorzystania dużych liczb przy użyciu komputera z systemem Quantum, o nazwie *factoring* .</span><span class="sxs-lookup"><span data-stu-id="0736d-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring* .</span></span>
<span data-ttu-id="0736d-193">Bezpieczeństwo wielu codziennych Cryptosystems opiera się na założeniu, że nie istnieje szybki algorytm do refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="0736d-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="0736d-194">Dlatego algorytm skró miał głęboki wpływ na to, jak sądzimy o zabezpieczeniach w świecie w urzędzie Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="0736d-195">Algorytm skró może być uważany za algorytm hybrydowy.</span><span class="sxs-lookup"><span data-stu-id="0736d-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="0736d-196">Komputer z systemem Quantum jest używany do wykonywania obliczeniowego zadania trwałego znanego jako wyszukiwanie okresów.</span><span class="sxs-lookup"><span data-stu-id="0736d-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="0736d-197">Wyniki wyszukiwania okresu są następnie przetwarzane w sposób klasyczny w celu oszacowania czynników.</span><span class="sxs-lookup"><span data-stu-id="0736d-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="0736d-198">Omawiamy poniższe dwa kroki.</span><span class="sxs-lookup"><span data-stu-id="0736d-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="0736d-199">Wyszukiwanie okresów</span><span class="sxs-lookup"><span data-stu-id="0736d-199">Period Finding</span></span> ###

<span data-ttu-id="0736d-200">Po zapoznaniu się z działaniem oceny Quantum Fouriera i oszacowaniem fazy (zobacz [algorytmy Quantum](xref:microsoft.quantum.libraries.standard.algorithms)) można użyć tych narzędzi do rozwiązywania problemów z *pewnymi* problemami.</span><span class="sxs-lookup"><span data-stu-id="0736d-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding* .</span></span>  <span data-ttu-id="0736d-201">W następnej sekcji zobaczymy, jak zastosować wyszukiwanie okresu do refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="0736d-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="0736d-202">Podano dwie liczby całkowite $a $ i $N $, gdzie $a<N $, cel szukania okresu, nazywane również kolejnością szukania, to znalezienie _zamówienia_ $r $ z $a $ modulo $N $, gdzie $r $ jest zdefiniowana jako najmniejsza dodatnia liczba całkowita, która $a ^ r \equiv 1 \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="0736d-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="0736d-203">Aby znaleźć kolejność przy użyciu komputera z systemem Quantum, możemy użyć algorytmu szacowania fazy stosowanego do poniższego operatora $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \Text{mod} N}. $ $ eigenvectors $U _a $ są dla liczby całkowitej $s $ i $0 \ LEQ s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i sk} {r}} \ket{a ^ k\text {mod} N}, $ $ są _eigenstates_ z $U _A $.</span><span class="sxs-lookup"><span data-stu-id="0736d-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="0736d-204">Eigenvalues $U _a $ to $ $ U \_ \ket{x \_ s} = e ^ {2 \ pi i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="0736d-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="0736d-205">Oszacowanie fazy w ten sposób wyprowadza eigenvalues $e ^ {2 \ pi i s/r} $, z którego $r $ można wydajniej poznać przy użyciu [ciągłego ułamków](https://en.wikipedia.org/wiki/Continued_fraction) z $s/r $.</span><span class="sxs-lookup"><span data-stu-id="0736d-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="0736d-206">Diagram obwodu dla wyszukiwania okresu Quantum to:</span><span class="sxs-lookup"><span data-stu-id="0736d-206">The circuit diagram for quantum period finding is:</span></span>

![Diagram obwodu dla wyszukiwania okresu Quantum](~/media/QPE.svg)

<span data-ttu-id="0736d-208">W tym miejscu $2n $ qubits są inicjowane do $ \ket {0} $, a $n $ qubits są inicjowane do $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="0736d-209">Czytelnik ponownie może się zastanawiać, dlaczego rejestr Quantum do przechowywania eigenstates jest zainicjowany do $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="0736d-210">Ponieważ nikt nie wie, że zamówienie $r $ z wyprzedzeniem, nie można rzeczywiście przygotować bezpośrednio Stanów $ \ket{x_s} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="0736d-211">Na szczęście, że spowoduje to wymienienie wartości $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="0736d-212">Nie musimy faktycznie przygotowywać $ \ket{x} $!</span><span class="sxs-lookup"><span data-stu-id="0736d-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="0736d-213">Można po prostu przygotować rejestr Quantum $n $ qubits w stanie $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="0736d-214">Obwód zawiera QFT i kilka bram, które są kontrolowane.</span><span class="sxs-lookup"><span data-stu-id="0736d-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="0736d-215">Brama QFT została [wcześniej](xref:microsoft.quantum.libraries.standard.algorithms)opisana.</span><span class="sxs-lookup"><span data-stu-id="0736d-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="0736d-216">Kontrolowane $U _a $ Gate Maps $ \ket{x} $ do $ \ket{(AX) \Text{mod} N} $, jeśli qubit kontrolki to $ \ket {1} $ i Maps $ \ket{x} $ do $ \ket{x} $ w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="0736d-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="0736d-217">Aby osiągnąć $ (a ^ NX) \Text{mod} N $, można po prostu zastosować kontrolowane $U _ {a ^ N} $, gdzie obliczamy $a ^ n \Text{mod} N $ w trybie klasycznym, aby podłączyć obwód do obwodu Quantum.</span><span class="sxs-lookup"><span data-stu-id="0736d-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="0736d-218">Obwody do osiągnięcia takich modularnych arytmetycznych zostały opisane w [dokumentacji arytmetycznej](./algorithms.md#arithmetic), w związku z czym potrzebujemy modularnego obwodu wykładniczego, aby zaimplementować operacje kontrolowane $U \_ {a} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="0736d-219">Chociaż obwód powyżej odnosi się do [szacowania fazy Quantum](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) i jawnie włącza wyszukiwanie zamówień, można zmniejszyć liczbę wymaganych qubits.</span><span class="sxs-lookup"><span data-stu-id="0736d-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="0736d-220">Możemy użyć metody Beauregard, aby znaleźć kolejność wyszukiwania zgodnie z opisem [na stronie 8 ArXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), lub skorzystać z jednej z procedur szacowania fazy dostępnych w Microsoft. Quantum. charakteryzującą.</span><span class="sxs-lookup"><span data-stu-id="0736d-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="0736d-221">Na przykład [niezawodna Ocena fazy](xref:microsoft.quantum.characterization.robustphaseestimation) używa również jednej dodatkowej qubit.</span><span class="sxs-lookup"><span data-stu-id="0736d-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="0736d-222">Wyprowadzenie</span><span class="sxs-lookup"><span data-stu-id="0736d-222">Factoring</span></span> ###
<span data-ttu-id="0736d-223">Celem jest określenie dwóch czynników zasadniczych liczby całkowitej $N $, gdzie $N $ jest numerem $n $-bitowym.</span><span class="sxs-lookup"><span data-stu-id="0736d-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="0736d-224">Refaktoryzacja składa się z kroków opisanych poniżej.</span><span class="sxs-lookup"><span data-stu-id="0736d-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="0736d-225">Kroki są podzielone na trzy części: klasyczne procedury przetwarzania wstępnego (1-4); Procedura przetwarzania Quantum, aby znaleźć kolejność $a \Text{mod} N $ (5); i klasyczną dostosujeszą procedurę, aby uzyskać podstawowe czynniki z porządku (6-9).</span><span class="sxs-lookup"><span data-stu-id="0736d-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="0736d-226">Procedura klasycznego przetwarzania wstępnego składa się z następujących kroków:</span><span class="sxs-lookup"><span data-stu-id="0736d-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="0736d-227">Jeśli $N $ jest parzysta, zwróć czynnik podstawowy $2 $.</span><span class="sxs-lookup"><span data-stu-id="0736d-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="0736d-228">Jeśli $N = p ^ q $ dla $p \geq1 $, $q \geq2 $, zwróć czynnik podstawowy $p $.</span><span class="sxs-lookup"><span data-stu-id="0736d-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="0736d-229">Ten krok jest wykonywany w trybie klasycznym.</span><span class="sxs-lookup"><span data-stu-id="0736d-229">This step is performed classically.</span></span>
3. <span data-ttu-id="0736d-230">Wybierz liczbę losową $a $ na przykład, że $1 < < N-$1.</span><span class="sxs-lookup"><span data-stu-id="0736d-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="0736d-231">Jeśli $ \Text{GCD} (a, N) >$1, zwróć czynnik podstawowy $ \Text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="0736d-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="0736d-232">Ten krok jest obliczany przy użyciu algorytmu Euklidesa.</span><span class="sxs-lookup"><span data-stu-id="0736d-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="0736d-233">Jeśli żaden czynnik podstawowy nie został zwrócony, przejdziemy do procedury Quantum:</span><span class="sxs-lookup"><span data-stu-id="0736d-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="0736d-234">Wywołaj algorytm wyszukiwania okresu Quantum, aby obliczyć kolejność $r $ of $a \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="0736d-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="0736d-235">Użyj $r $ w klasycznej procedurze dostosujesz, aby określić podstawowe czynniki:</span><span class="sxs-lookup"><span data-stu-id="0736d-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="0736d-236">Jeśli $r $ jest nieparzysta, Wróć do kroku przetwarzania wstępnego (3).</span><span class="sxs-lookup"><span data-stu-id="0736d-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="0736d-237">Jeśli $r $ jest parzysta i $a ^ {r/2} =-1 \ Text {mod} N $, Wróć do kroku przetwarzania wstępnego (3).</span><span class="sxs-lookup"><span data-stu-id="0736d-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="0736d-238">Jeśli $ \Text{GCD} (^ {r/2} + 1, N) $ jest nieprostym czynnikiem $N $, zwróć $ \Text{GCD} (^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="0736d-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="0736d-239">Jeśli $ \Text{GCD} (^ {r/2}-1, N) $ jest nieprostym czynnikiem $N $, zwróć $ \Text{GCD} (^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="0736d-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="0736d-240">Algorytm refaktoryzacji to probabilistyczne: może być pokazywany, że z prawdopodobieństwem co najmniej jedna połowa, która $r $, będzie parzysta i $a ^ {r/2} \neq-1 \Text{mod} N $, dzięki czemu jest to czynnik podstawowy.</span><span class="sxs-lookup"><span data-stu-id="0736d-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="0736d-241">(Zobacz [oryginalny dokument skró](https://doi.org/10.1109/SFCS.1994.365700) , aby uzyskać szczegółowe informacje, lub jeden z *podstawowych tekstów przetwarzania Quantum* w programie, [Aby uzyskać więcej informacji](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="0736d-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="0736d-242">Jeśli czynnik podstawowy nie jest zwracany, po prostu Powtórzmy algorytm od kroku (1).</span><span class="sxs-lookup"><span data-stu-id="0736d-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="0736d-243">Po $n $ próby, prawdopodobieństwo, że każda próba nie powiodła się, jest najwyżej $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="0736d-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="0736d-244">W takim przypadku po powtarzaniu algorytmu niewielka liczba sukcesów jest praktycznie gwarantowana.</span><span class="sxs-lookup"><span data-stu-id="0736d-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
