---
title: Scharakteryzowanie i statystyka Quantum
description: Dowiedz się, jak dane statystyczne pomiarów z szacowania fazy są używane do szacowania wartości wyników w programowaniu Quantum.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 51e7b3bcf4402a4d0ba5647643f284e9f10c3bb3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692160"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="a162d-103">Scharakteryzowanie i statystyka Quantum</span><span class="sxs-lookup"><span data-stu-id="a162d-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="a162d-104">Niezwykle ważne jest, aby mieć możliwość scharakteryzowania skutków operacji w celu opracowania przydatnych algorytmów Quantum.</span><span class="sxs-lookup"><span data-stu-id="a162d-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="a162d-105">Jest to trudne, ponieważ każde pomiary systemu Quantum daje maksymalnie jeden bit informacji.</span><span class="sxs-lookup"><span data-stu-id="a162d-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="a162d-106">Aby uzyskać informacje o eigenvalue, powiadom sam stan Quantum, wyniki wielu pomiarów muszą być połączone, aby użytkownik mógł zgłębiać wiele informacji potrzebnych do reprezentowania tych koncepcji.</span><span class="sxs-lookup"><span data-stu-id="a162d-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="a162d-107">Stany Quantum są szczególnie uciążliwych z powodu braku [klonowania theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) , że nie ma możliwości poznania dowolnego stanu Quantum z pojedynczej kopii stanu, ponieważ dzięki temu można tworzyć kopie stanu.</span><span class="sxs-lookup"><span data-stu-id="a162d-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="a162d-108">Ta zaciemnianie stanu Quantum od użytkownika jest odzwierciedlane w rzeczywistości, która Q# nie ujawnia ani nie definiuje stanu dla programów Quantum. *is*</span><span class="sxs-lookup"><span data-stu-id="a162d-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="a162d-109">W ten sposób zbliżamy się do charakterystyki Quantum przez traktowanie operacji i Stanów jako czarnych. Ta metoda jest często wspólna w przypadku eksperymentalnej praktycznej charakterystyki Quantum, weryfikacji i weryfikacji (QCVV).</span><span class="sxs-lookup"><span data-stu-id="a162d-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="a162d-110">Scharakteryzowanie różni się od wielu innych omawianych wcześniej bibliotek.</span><span class="sxs-lookup"><span data-stu-id="a162d-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="a162d-111">Celem tej funkcji jest mniej, aby poznać klasyczne informacje o systemie, a nie przekształcenie jednostkowe na wektor stanu.</span><span class="sxs-lookup"><span data-stu-id="a162d-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="a162d-112">W związku z tym te biblioteki muszą mieszać zarówno klasyczne, jak i Quantum przetwarzanie informacji.</span><span class="sxs-lookup"><span data-stu-id="a162d-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="a162d-113">Szacowanie fazy iteracji</span><span class="sxs-lookup"><span data-stu-id="a162d-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="a162d-114">Wyświetlanie programowania Quantum w kontekście określania klasy Quantum sugeruje przydatną alternatywę dla szacowania fazy Quantum.</span><span class="sxs-lookup"><span data-stu-id="a162d-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="a162d-115">Oznacza to, że zamiast przygotował $n $-qubit Register, aby zawierał binarną reprezentację fazy w ramach szacowania fazy Quantum, możemy wyświetlić oszacowanie fazy jako proces, za pomocą którego Agent *klasyczny* uczy właściwości systemu Quantum poprzez pomiary.</span><span class="sxs-lookup"><span data-stu-id="a162d-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="a162d-116">Przejdziemy tak jak w przypadku Quantum w przypadku użycia fazy Kickback, aby przekształcić aplikacje dla operacji czarno o nieznanym kącie, ale będzie to miara Ancilla qubit, które obracamy się w każdym kroku bezpośrednio po rotacji.</span><span class="sxs-lookup"><span data-stu-id="a162d-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="a162d-117">Jest to zalety, że wymaga tylko pojedynczej dodatkowej qubit do wykonania fazy KickBack opisanej w przypadku Quantum, ponieważ następnie uczymy fazę od wyników pomiaru w każdym kroku w sposób iteracyjny.</span><span class="sxs-lookup"><span data-stu-id="a162d-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="a162d-118">Każda z metod proponowanych poniżej używa innej strategii do projektowania eksperymentów i różnych metod przetwarzania danych w celu uzyskania informacji o fazie.</span><span class="sxs-lookup"><span data-stu-id="a162d-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="a162d-119">Każdy z nich ma unikatową korzyść w zakresie od uzyskania rygorystycznych powiązań błędów, do możliwości uwzględniania wcześniejszych informacji, tolerowania błędów lub uruchamiania w pamięci limitted klasyczne komputery.</span><span class="sxs-lookup"><span data-stu-id="a162d-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="a162d-120">W omawianiu oszacowania fazy iteracyjnej będziemy rozważać $U jednostkowe $ podaną jako operację czerni.</span><span class="sxs-lookup"><span data-stu-id="a162d-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="a162d-121">Zgodnie z opisem w sekcji dotyczącej rozwiązań firmy Oracle w [strukturach danych](xref:microsoft.quantum.libraries.data-structures)firmy Q# Canon modeluje takie operacje według <xref:Microsoft.Quantum.Oracles.DiscreteOracle> typu zdefiniowanego przez użytkownika, zdefiniowanego przez typ krotki `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="a162d-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="a162d-122">W konkretnym przypadku, `U : DiscreteOracle` a następnie `U(m)` implementuje $U ^ m $ dla `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="a162d-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="a162d-123">W przypadku tej definicji, każdy krok iteracji fazy szacowania kontynuuje proces przygotowywania pomocniczej qubit w stanie $ \ket{+} $ wraz z początkowym stanem $ \ket{\phi} $ przyjętym przez nas jest [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) $U (m) $, tj. $U (m) \ket{\phi} = e ^ {im\phi} \ KET {\ Fi} $.</span><span class="sxs-lookup"><span data-stu-id="a162d-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="a162d-124">`U(m)`Następnie zostanie użyta aplikacja, która przygotuje stan $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="a162d-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="a162d-125">Podobnie jak w przypadku Quantum, wpływ kontrolowanej aplikacji Oracle `U(m)` jest dokładnie taki sam, jak efekt zastosowania $R _1 $ dla nieznanej fazy w $ \ket{+} $, dzięki czemu możemy opisać efekty $U $ w ten sposób prostsze.</span><span class="sxs-lookup"><span data-stu-id="a162d-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="a162d-126">Opcjonalnie algorytm obraca qubit kontrolki, stosując $R _1 (-m\theta) $, aby uzyskać stan $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="a162d-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="a162d-127">Pomocnicza qubit używana jako kontrolka `U(m)` jest następnie mierzona na podstawie $X $ w celu uzyskania jednego klasycznego `Result` .</span><span class="sxs-lookup"><span data-stu-id="a162d-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="a162d-128">W tym momencie Rekonstruowanie fazy z `Result` wartości uzyskanych za pomocą szacowania fazy iteracyjnej jest klasycznym problemem statystycznym wnioskowania.</span><span class="sxs-lookup"><span data-stu-id="a162d-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="a162d-129">Znalezienie wartości $m $, która maksymalizuje zdobyte informacje, z uwzględnieniem ustalonej metody wnioskowania, jest po prostu problemem w statystyce.</span><span class="sxs-lookup"><span data-stu-id="a162d-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="a162d-130">Podkreślamy to, krótko opisując ocenę fazy iteracyjnej na poziomie teoretycznym w formalnym zakresie szacowania parametrów bayesowskie przed przystąpieniem do opisywania algorytmu statystycznego dostępnego w firmie Q# Canon do rozwiązywania tego problemu.</span><span class="sxs-lookup"><span data-stu-id="a162d-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="a162d-131">Szacowanie fazy iteracyjnej bez Eigenstates</span><span class="sxs-lookup"><span data-stu-id="a162d-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="a162d-132">Jeśli podany jest stan wejściowy, który nie jest eigenstate, co oznacza, że jeśli $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $, wówczas proces szacowania fazy nie jest w sposób jednoznaczny zorientowany na pojedynczy eigenstate energetyczny.</span><span class="sxs-lookup"><span data-stu-id="a162d-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="a162d-133">Eigenstate, do którego ostatecznie jest zbieżny, jest eigenstate, który najprawdopodobniej wyprodukował obserwowane `Result` .</span><span class="sxs-lookup"><span data-stu-id="a162d-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="a162d-134">W odniesieniu do jednego kroku środowiska uruchomieniowego jest wykonywana następująca niezależna transformacja na stanie \begin{align} \ sum_j \sqrt{\Pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ sqrt {\ PR (\phi \_ j)} \sqrt{\Pr (\Text{Result} | \phi \_ j)} \Ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \sum \_ j \Pr (\Text{Result} | \phi \_ j)}}.</span><span class="sxs-lookup"><span data-stu-id="a162d-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="a162d-135">\end{align}, ponieważ ten proces jest powtarzany przez wiele `Result` wartości, eigenstates, które nie mają maksymalnych wartości $ \ prod_k \pr (\Text{Result} \_ k | \phi \_ j) $ zostanie pominięty wykładniczo.</span><span class="sxs-lookup"><span data-stu-id="a162d-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="a162d-136">W efekcie proces wnioskowania będzie przerastał zbieżność do Stanów o pojedynczej eigenvalue, jeśli eksperymenty są wybrane prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="a162d-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="a162d-137">Bayesa ' theorem dodatkowo sugeruje, że stan, który wynika z oszacowania fazy, jest zapisywana w postaci \begin{align} \frac{\sqrt{\Pr (\phi \_ j)} \sqrt{\Pr (\Text{Result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \Sum \_ j \Pr (\Text{Result} | \phi \_ j)}} = \ sum_j \sqrt{\Pr (\phi \_ j | \Text{Result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="a162d-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="a162d-138">\end{align} tutaj $ \Pr (\phi \_ j | \Text{Result}) $ może być interpretted jako prawdopodobieństwo, że jeden z nich będzie miał wartość ascribe do każdej hipotezy dotyczącej danego eigenstatesu:</span><span class="sxs-lookup"><span data-stu-id="a162d-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="a162d-139">znajomość stanu Quantum przed pomiarem,</span><span class="sxs-lookup"><span data-stu-id="a162d-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="a162d-140">znajomość eigenstatesów $U $ i,</span><span class="sxs-lookup"><span data-stu-id="a162d-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="a162d-141">znajomość eigenvaluesów $U $.</span><span class="sxs-lookup"><span data-stu-id="a162d-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="a162d-142">Uczenie tych trzech rzeczy jest często wykładnicze na klasycznym komputerze.</span><span class="sxs-lookup"><span data-stu-id="a162d-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="a162d-143">Narzędzie do szacowania faz ma wpływ na to, że nie jest to niewielki zakres, od faktu, że może wykonywać takie zadanie uczenia Quantum bez znajomości jakichkolwiek z nich.</span><span class="sxs-lookup"><span data-stu-id="a162d-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="a162d-144">Oszacowanie fazy z tego powodu występuje w wielu algorytmach Quantum, które udostępniają wykładniczą przyspieszenia.</span><span class="sxs-lookup"><span data-stu-id="a162d-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="a162d-145">Oszacowanie fazy bayesowskie</span><span class="sxs-lookup"><span data-stu-id="a162d-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="a162d-146">Aby uzyskać więcej informacji na temat szacowania fazy bayesowskie w sposób, zobacz przykład [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="a162d-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="a162d-147">Koncepcja szacowania fazy bayesowskie jest prosta.</span><span class="sxs-lookup"><span data-stu-id="a162d-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="a162d-148">Dane statystyczne pomiarów można zbierać z poziomu protokołu szacowania fazy, a następnie przetwarzać wyniki przy użyciu wnioskowania bayesowskie i podać oszacowanie parametru.</span><span class="sxs-lookup"><span data-stu-id="a162d-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="a162d-149">To przetwarzanie zapewnia oszacowanie eigenvalue oraz niepewność w tym szacunku.</span><span class="sxs-lookup"><span data-stu-id="a162d-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="a162d-150">Umożliwia również przeprowadzanie eksperymentów adaptacyjnych i korzystanie z wcześniejszych informacji.</span><span class="sxs-lookup"><span data-stu-id="a162d-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="a162d-151">Reguła "wadą" metod jest, że jest to wymaganie obliczeniowe.</span><span class="sxs-lookup"><span data-stu-id="a162d-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="a162d-152">Aby zrozumieć, jak działa ten proces wnioskowania bayesowskie, rozważ przypadek przetwarzania pojedynczego `Zero` wyniku.</span><span class="sxs-lookup"><span data-stu-id="a162d-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="a162d-153">Należy pamiętać, że $X = \ket{+} \bra{+}-\ket {-} \bra {-} $, tak że $ \ket{+} $ jest jedyną dodatnią eigenstateem $X $ odpowiadającym `Zero` .</span><span class="sxs-lookup"><span data-stu-id="a162d-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="a162d-154">Prawdopodobieństwo zaobserwowania `Zero` dla [ `PauliX` pomiaru](xref:microsoft.quantum.concepts.pauli) na pierwszym qubitu ze stanem wejściowym $ \ket{\psi}\ket{\phi} $ to w ten sposób \begin{Equation} \Pr (\texttt{zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="a162d-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="a162d-155">\end{Equation} w przypadku iteracji fazy iteracyjnej mamy, że $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, takich jak \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: faza-Est — prawdopodobieństwo}.</span><span class="sxs-lookup"><span data-stu-id="a162d-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="a162d-156">\end{align} to jest, iteracyjne szacowanie faz polega na uczeniu częstotliwości drgań funkcji sinusoidalną, pod kątem możliwości odwrócenia monety z odchyleniami podaną przez sinusoid.</span><span class="sxs-lookup"><span data-stu-id="a162d-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="a162d-157">Zgodnie z tradycyjną klasyczną terminologią, wywołamy metodę $ \eqref{EQ: Phase-Est — prawdopodobieństwo} $ *Funkcja prawdopodobieństwa* dla szacowania fazy iteracji.</span><span class="sxs-lookup"><span data-stu-id="a162d-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="a162d-158">Po zaobserwowanym `Result` z funkcji prawdopodobieństwo oszacowania fazy iteracji możemy użyć reguły Bayesa ', aby określić, co powinna być uważana za tę obserwację.</span><span class="sxs-lookup"><span data-stu-id="a162d-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="a162d-159">W konkretnym miejscu \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} WHERE $d \In \\ {\texttt{zero}, \texttt{one} \\ } $ to a `Result` , gdzie $ \Pr (\phi) $ opisuje poprzednią przekonania o $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="a162d-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="a162d-160">Powoduje to, że iteracyjny charakter iteracyjnej oceny fazy jest jawny, jako rozkład tylny $ \Pr (\phi | d) $ opisuje nasze przekonania bezpośrednio przed naszymi obserwacją następnego `Result` .</span><span class="sxs-lookup"><span data-stu-id="a162d-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="a162d-161">W dowolnym momencie podczas tej procedury możemy raportować fazę $ \hat{\phi} $ wnioskowaną przez klasyczny kontroler jako \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \Text{data}] = \int \phi \Pr (\phi | \Text{Data}) {\mathrm d} \phi, \end{Equation}, gdzie $ \Text{Data} $ oznacza cały otrzymany rekord wszystkich `Result` uzyskanych wartości.</span><span class="sxs-lookup"><span data-stu-id="a162d-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="a162d-162">Dokładne wnioskowanie bayesowskie jest w sposób nieodpowiedniy do przeprowadzenia.</span><span class="sxs-lookup"><span data-stu-id="a162d-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="a162d-163">Aby wyświetlić ten obraz, chcielibyśmy poznać zmienną $n $-bitową $x $.</span><span class="sxs-lookup"><span data-stu-id="a162d-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="a162d-164">Wcześniejsza dystrybucja $ \Pr (x) $ ma obsługę ponad $2 ^ n $ hipotetycznych wartości $x $.</span><span class="sxs-lookup"><span data-stu-id="a162d-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="a162d-165">Oznacza to, że jeśli potrzebujemy wysoce dokładnego oszacowania $x $, szacowanie fazy bayesowskie może wymagać zabraniania pamięci i czasu przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="a162d-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="a162d-166">Chociaż w przypadku niektórych aplikacji, takich jak symulacja Quantum, wymagana dokładność limitted nie wyklucza takich metod inne aplikacje, takie jak skró, nie można użyć dokładnej bayesowskie wnioskowania w ramach etapu szacowania fazy.</span><span class="sxs-lookup"><span data-stu-id="a162d-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="a162d-167">Z tego powodu udostępniamy również implementacje przybliżonych metod bayesowskie, takich jak [szacowanie etapowych przeszukiwań (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) , a także inne podejścia niebayesowskieowe, takie jak [niezawodna Ocena faz](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="a162d-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="a162d-168">Niezawodna Ocena fazy</span><span class="sxs-lookup"><span data-stu-id="a162d-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="a162d-169">Maksymalna bayesowskie odbudowy fazy *szacowania z wyników* pomiarów jest wykładniczo trudna w najgorszym przypadku.</span><span class="sxs-lookup"><span data-stu-id="a162d-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="a162d-170">W ten sposób większość praktycznych algorytmów szacowania fazy pogorszy pewną jakość w odbudowie, w programie Exchange dla ilości klasycznego przetwarzania końcowego, który zamiast tego skaluje się wielomianowo z liczbą wykonanych pomiarów.</span><span class="sxs-lookup"><span data-stu-id="a162d-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="a162d-171">Jednym z takich przykładów z wydajnym klasycznym etapem przetwarzania jest [niezawodny algorytm szacowania fazy](https://arxiv.org/abs/1502.02677), z jego sygnaturą i danymi wejściowymi wymienionymi powyżej.</span><span class="sxs-lookup"><span data-stu-id="a162d-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="a162d-172">Przyjęto założenie, że wejściowe pola $U $ są opakowane jako `DiscreteOracle` Typ, i w związku z tym tylko wykonuje zapytania w postaci liczby całkowitej dla kontrolowanej $U $.</span><span class="sxs-lookup"><span data-stu-id="a162d-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="a162d-173">Jeśli dane wejściowe w `Qubit[]` rejestrze to eigenstate $U \ket{\psi} = e ^ {i\phi} \ KET {\ psi} $, algorytm szacowania fazy niezawodnej zwraca oszacowanie $ \hat{\phi}\In [-\pi, \pi) $ z $ \phi $ jako `Double` .</span><span class="sxs-lookup"><span data-stu-id="a162d-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="a162d-174">Najważniejszym elementem niezawodnym oszacowania fazy, który jest współużytkowany z większością użytecznych wariantów, jest to, że jakość budowy klasy $ \hat{\phi} $ jest w pewnym sensie Heisenberg-Limited.</span><span class="sxs-lookup"><span data-stu-id="a162d-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="a162d-175">Oznacza to, że jeśli odchylenie $ \hat{\phi} $ od prawdziwej wartości to $ \sigma $, a $ \sigma $ jest skalowane proporcjonalnie do całkowitej liczby zapytań $Q $ wykonane do kontroli $U $, tj. $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="a162d-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="a162d-176">Teraz definicja odchylenia różni się od różnych algorytmów szacowania.</span><span class="sxs-lookup"><span data-stu-id="a162d-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="a162d-177">W niektórych przypadkach może to oznaczać, że w przypadku co najmniej $ \mathcal{O} (1) $ prawdopodobieństwa błąd szacowania $ | \hat{\phi}-\phi | \_ \circ\le \sigma $ dla pewnej miary cyklicznej $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="a162d-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="a162d-178">W przypadku niezawodnych ocen fazy, odchylenie jest dokładne od wariancji $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $ Jeśli rozwinie okresowe fazy do jednego skończonego interwału $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="a162d-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="a162d-179">Dokładniej, odchylenie standardowe w niezawodnej ocenie fazy jest zgodne ze znakiem nierówności $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10,7 \ pi/Q, \end{align} $ $, gdzie Dolna granica jest osiągnięta w limicie asymptotically duży $Q $, a górna granica jest gwarantowana nawet dla małych rozmiarów próbek.</span><span class="sxs-lookup"><span data-stu-id="a162d-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="a162d-180">Należy pamiętać, że $n $ wybranych przez `bitsPrecision` dane wejściowe, które niejawnie definiuje $Q $.</span><span class="sxs-lookup"><span data-stu-id="a162d-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="a162d-181">Inne istotne szczegóły obejmują:, na przykład, obciążenie małą ilością tylko $1 $ Ancilla qubit lub że procedura jest nieadaptacyjna, co oznacza, że wymagana sekwencja eksperymentów Quantum jest niezależna od wyników pomiaru pośredniego.</span><span class="sxs-lookup"><span data-stu-id="a162d-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="a162d-182">W tym i przemieszczonych przykładach, w których jest ważne, aby wybrać algorytm szacowania fazy, należy zapoznać się z dokumentacją, taką jak @"microsoft.quantum.characterization.robustphaseestimation" i publikacjami, do których istnieją odwołania, aby uzyskać więcej informacji i ich implementacji.</span><span class="sxs-lookup"><span data-stu-id="a162d-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="a162d-183">Istnieje wiele przykładów, w których jest używane niezawodne szacowanie faz.</span><span class="sxs-lookup"><span data-stu-id="a162d-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="a162d-184">W przypadku szacowania fazy w przypadku wyodrębnienia energii stanu ziemi w różnych systemach fizycznych należy zapoznać się z przykładem [ **symulacji H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), [przykładem **SimpleIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)i [przykładowym **modelem Hubbard**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="a162d-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="a162d-185">Ciągłe firmy Oracle</span><span class="sxs-lookup"><span data-stu-id="a162d-185">Continuous Oracles</span></span> ###

<span data-ttu-id="a162d-186">Możemy również uogólnić z modelu Oracle użytego powyżej, aby umożliwić korzystanie z Oracle w czasie ciągłym, które są modelowane przez typ firmy <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="a162d-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="a162d-187">Rozważmy, że zamiast pojedynczego operatora jednostkowego $U $, mamy rodzinę operatorów jednostkowych $U (t) $ for $t \In \mathbb{R} $, takich jak $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="a162d-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="a162d-188">Jest to słaba instrukcja, niż w przypadku odrębnego przypadku, ponieważ możemy utworzyć element, <xref:Microsoft.Quantum.Oracles.DiscreteOracle> ograniczając $t = m \, \delta t $ dla niektórych stałych $ \delta t $.</span><span class="sxs-lookup"><span data-stu-id="a162d-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="a162d-189">Według [theorem kamienia](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ dla pewnego operatora $H $, gdzie $ \exp $ to macierz wykładnicza, zgodnie z opisem w [zaawansowanych macierzach](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="a162d-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="a162d-190">Eigenstate $ \ket{\phi} $ $H $, które $H \ket{\phi} = \phi \ket{\phi} $, również eigenstate of $U (t) $ dla wszystkich $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="a162d-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="a162d-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="a162d-191">\end{equation}</span></span>

<span data-ttu-id="a162d-192">Można zastosować dokładnie tę samą analizę omówioną w przypadku [szacowania fazy bayesowskie](#bayesian-phase-estimation) , a funkcja prawdopodobieństwo jest dokładnie taka sama dla tego bardziej ogólnego modelu Oracle: $ $ \Pr (\texttt{zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="a162d-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="a162d-193">$ $ Ponadto, jeśli $U $ to symulacja dynamicznego generatora, tak jak w przypadku [symulacji hamiltonian](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), interpretujemy $ \phi $ jako energię.</span><span class="sxs-lookup"><span data-stu-id="a162d-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="a162d-194">W rezultacie użycie szacowania fazy z ciągłymi zapytaniami pozwala nam poznać symulowany [zakres energii dla cząsteczek](https://arxiv.org/abs/quant-ph/0604193), [materiałów](https://arxiv.org/abs/1510.03859) lub [pola teorie](https://arxiv.org/abs/1111.3633v2) , bez konieczności naruszania wybranych eksperymentów, wymagając $t $ jako liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a162d-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="a162d-195">Szacowanie fazy losowego przeszukiwania</span><span class="sxs-lookup"><span data-stu-id="a162d-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="a162d-196">Q# zapewnia przydatne przybliżenie oceny fazy bayesowskie przeznaczonej do użycia w pobliżu urządzeń Quantum, które działają przez Kondycjonowanie losowego przeszukiwania rekordów danych uzyskanych z oszacowania fazy iteracyjnej.</span><span class="sxs-lookup"><span data-stu-id="a162d-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="a162d-197">Ta metoda jest zarówno adaptacyjna, jak i całkowicie deterministyczna, co pozwala na niemal optymalne skalowanie błędów w szacowanej fazie $ \hat{\phi} $ z bardzo niewielką ilością pamięci.</span><span class="sxs-lookup"><span data-stu-id="a162d-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="a162d-198">Protokół używa przybliżonej metody wnioskowania bayesowskie, która zakłada, że wcześniejsza dystrybucja to gaussowskie.</span><span class="sxs-lookup"><span data-stu-id="a162d-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="a162d-199">To założenie gaussowskie pozwala nam używać formuły analitycznej dla eksperymentu, który minimalizuje wariancję tylną.</span><span class="sxs-lookup"><span data-stu-id="a162d-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="a162d-200">Następnie algorytm, w oparciu o wynik tego eksperymentu, przenosi wartość $ \phi $ left lub right w dół według wstępnie ustalonej wartości i zmniejsza wariancję według wstępnie ustalonej wartości.</span><span class="sxs-lookup"><span data-stu-id="a162d-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="a162d-201">Ta średnia i Wariancja zawierają wszystkie informacje, które są konieczne do określenia gaussowskie przed elementem $ \phi $ dla następnego eksperymentu.</span><span class="sxs-lookup"><span data-stu-id="a162d-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="a162d-202">Nieoczekiwane błędy pomiarowe lub rzeczywisty wynik na końcach początkowego poprzedzającego, może to spowodować niepowodzenie tej metody.</span><span class="sxs-lookup"><span data-stu-id="a162d-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="a162d-203">Odzyskuje się od awarii przez przeprowadzenie eksperymentów w celu sprawdzenia, czy bieżąca średnia i odchylenie standardowe są odpowiednie dla systemu.</span><span class="sxs-lookup"><span data-stu-id="a162d-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="a162d-204">Jeśli nie, wówczas algorytm wykonuje przechodzenie krok po kroku, a proces jest kontynuowany.</span><span class="sxs-lookup"><span data-stu-id="a162d-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="a162d-205">Możliwość przechodzenie do tyłu pozwala również algorytmowi dowiedzieć się, nawet jeśli początkowe odchylenie standardowe jest inapropriately małe.</span><span class="sxs-lookup"><span data-stu-id="a162d-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="a162d-206">Algorytmy szacowania fazy wywołania</span><span class="sxs-lookup"><span data-stu-id="a162d-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="a162d-207">Każda operacja szacowania fazy dostarczana z użyciem firmy Q# Canon przyjmuje inny zestaw danych wejściowych parametryzacja jakość, której potrzebujemy z końcowego oszacowania $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="a162d-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="a162d-208">Te różne dane wejściowe, jednak wspólnie współdzielą kilka danych wejściowych, takie jak częściowa aplikacja przez parametry jakości, skutkuje typowym podpisem.</span><span class="sxs-lookup"><span data-stu-id="a162d-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="a162d-209">Na przykład <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operacja omówiona w następnej sekcji ma następujący podpis:</span><span class="sxs-lookup"><span data-stu-id="a162d-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="a162d-210">`bitsPrecision`Dane wejściowe są unikatowe dla `RobustPhaseEstimation` , chociaż `oracle` i `eigenstate` są wspólne.</span><span class="sxs-lookup"><span data-stu-id="a162d-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="a162d-211">Tak więc, jak widać w **H2Sample** , operacja może akceptować algorytm iteracyjnej oceny fazy z wejściem formularza, `(DiscreteOracle, Qubit[]) => Unit` Aby zezwolić użytkownikowi na określenie dowolnych algorytmów szacowania fazy:</span><span class="sxs-lookup"><span data-stu-id="a162d-211">Thus, as seen in **H2Sample** , an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="a162d-212">Te algorytmy szacowania fazy wyposażono są zoptymalizowane pod kątem różnych właściwości i parametrów wejściowych, które należy zrozumieć w celu zapewnienia najlepszego wyboru dla aplikacji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a162d-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="a162d-213">Na przykład niektóre algorytmy szacowania fazy są adaptacyjne, co oznacza, że przyszłe kroki są kontrolowane w sposób klasyczny przez wyniki pomiarów poprzednich kroków.</span><span class="sxs-lookup"><span data-stu-id="a162d-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="a162d-214">Niektóre z nich wymagają możliwości exponentiate swojej wbudowanej sieci firmy Oracle z dowolnymi rzeczywistymi uprawnieniami, a inne wymagają tylko liczby całkowitej, ale mogą jedynie rozpoznać oszacowanie fazy modulo $2 \ pi $.</span><span class="sxs-lookup"><span data-stu-id="a162d-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="a162d-215">Niektóre wymagają wielu pomocniczych qubits, a inne wymagają tylko jednego.</span><span class="sxs-lookup"><span data-stu-id="a162d-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="a162d-216">Podobnie użycie szacowania fazy losowego przeszukiwania przebiega w podobny sposób, jak w przypadku innych algorytmów udostępnianych w języku Canon:</span><span class="sxs-lookup"><span data-stu-id="a162d-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
