---
title: Struktury danych w Q# bibliotekach standardowych
description: Informacje na temat struktur danych, Oracle i dynamicznych generatorów w Q# bibliotekach standardowych firmy Microsoft.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: e9b593ba69ed41a9fb3c1298b5b945a4cbe43d5d
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858329"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="65534-103">Struktury i modelowanie danych</span><span class="sxs-lookup"><span data-stu-id="65534-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="65534-104">Klasyczne struktury danych</span><span class="sxs-lookup"><span data-stu-id="65534-104">Classical Data Structures</span></span> ##

<span data-ttu-id="65534-105">Wraz z typami zdefiniowanymi przez użytkownika do reprezentowania koncepcji Quantum, Canon oferuje również operacje, funkcje i typy do pracy z danymi klasycznymi używanymi w kontroli systemów Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="65534-106">Na przykład <xref:Microsoft.Quantum.Arrays.Reversed> Funkcja przyjmuje tablicę jako dane wejściowe i zwraca tę samą tablicę w odwrotnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="65534-106">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="65534-107">Można go następnie użyć w tablicy typu, `Qubit[]` Aby uniknąć konieczności stosowania niepotrzebnych bram $ \operatorname{swap} $ podczas konwersji między reprezentacjami jednostek Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="65534-108">Podobnie znaleźliśmy w poprzedniej sekcji, że typy formularzy `(Int, Int -> T)` mogą być przydatne do reprezentowania losowych kolekcji dostępu, więc <xref:Microsoft.Quantum.Arrays.LookupFunction> Funkcja zapewnia wygodny sposób konstruowania takich typów z typów tablic.</span><span class="sxs-lookup"><span data-stu-id="65534-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:Microsoft.Quantum.Arrays.LookupFunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="65534-109">Parowanie</span><span class="sxs-lookup"><span data-stu-id="65534-109">Pairs</span></span> ###

<span data-ttu-id="65534-110">Firma Canon obsługuje notację w stylu funkcjonalnym dla par, uzupełniając dostęp do krotek przez dekonstrukcja:</span><span class="sxs-lookup"><span data-stu-id="65534-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="65534-111">Tablice</span><span class="sxs-lookup"><span data-stu-id="65534-111">Arrays</span></span> ###

<span data-ttu-id="65534-112">Canon oferuje kilka funkcji manipulowania tablicami.</span><span class="sxs-lookup"><span data-stu-id="65534-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="65534-113">Te funkcje są typu sparametryzowanego i mogą być używane z tablicami dowolnego Q# typu.</span><span class="sxs-lookup"><span data-stu-id="65534-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="65534-114">Na przykład <xref:Microsoft.Quantum.Arrays.Reversed> Funkcja zwraca nową tablicę, której elementy znajdują się w odwrotnej kolejności od ich wejścia.</span><span class="sxs-lookup"><span data-stu-id="65534-114">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="65534-115">Może to służyć do zmiany sposobu reprezentowania rejestru Quantum podczas wywoływania operacji:</span><span class="sxs-lookup"><span data-stu-id="65534-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="65534-116">Podobnie <xref:Microsoft.Quantum.Arrays.Subarray> Funkcja może służyć do zmiany kolejności lub podzbiorów elementów tablicy:</span><span class="sxs-lookup"><span data-stu-id="65534-116">Similarly, the <xref:Microsoft.Quantum.Arrays.Subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="65534-117">W połączeniu z sterowaniem przepływem funkcje manipulowania tablicą, takie jak <xref:Microsoft.Quantum.Arrays.Zipped> mogą zapewnić zaawansowany sposób wyznaczania programów Quantum:</span><span class="sxs-lookup"><span data-stu-id="65534-117">When combined with flow control, array manipulation functions such as <xref:Microsoft.Quantum.Arrays.Zipped> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zipped([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="65534-118">Firmy Oracle</span><span class="sxs-lookup"><span data-stu-id="65534-118">Oracles</span></span> ##

<span data-ttu-id="65534-119">W [ocenie fazy](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) i literaturze [wzmocnienia amplitudy](https://en.wikipedia.org/wiki/Amplitude_amplification) koncepcje Oracle często pojawiają się.</span><span class="sxs-lookup"><span data-stu-id="65534-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="65534-120">W tym miejscu termin Oracle odnosi się do procedury podrzędnej Quantum, która działa na zestawie qubits i zwraca odpowiedź jako fazę.</span><span class="sxs-lookup"><span data-stu-id="65534-120">Here the term oracle refers to a quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="65534-121">Ta podprocedura często może być traktowana jako dane wejściowe algorytmu Quantum, który akceptuje Oracle, oprócz innych parametrów, i stosuje szereg operacji Quantum i traktowanie wywołania tej podprocedury Quantum, tak jakby była bramą podstawową.</span><span class="sxs-lookup"><span data-stu-id="65534-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="65534-122">Oczywiście, aby faktycznie zaimplementować większy algorytm, należy podać konkretną dekompozycję Oracle do podstawowych bram, ale takie dekompozycja nie jest wymagana w celu zrozumienia algorytmu, który wywołuje Oracle.</span><span class="sxs-lookup"><span data-stu-id="65534-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="65534-123">W programie Q# to streszczenie jest reprezentowane przez użycie tych operacji jako wartości pierwszej klasy, na przykład, że operacje mogą być przesyłane do implementacji algorytmów Quantum w sposób czarno-Box.</span><span class="sxs-lookup"><span data-stu-id="65534-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="65534-124">Ponadto typy zdefiniowane przez użytkownika są używane do etykietowania różnych reprezentacji Oracle w sposób bezpieczny dla typu, co utrudnia przypadkowe rozliczanie różnych rodzajów operacji na czarnym pudełku.</span><span class="sxs-lookup"><span data-stu-id="65534-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="65534-125">Takie firmy Oracle są wyświetlane w wielu różnych kontekstach, w tym w przykładach sławę, takich jak [Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) i algorytmy symulacji Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="65534-126">W tym miejscu koncentrujemy się na systemach Oracle wymaganych przez tylko dwie aplikacje: wzmocnienie amplitudy i szacowanie faz.</span><span class="sxs-lookup"><span data-stu-id="65534-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="65534-127">Najpierw będziemy omawiać wzmocnienie wzmocnienia amplitudy przed rozpoczęciem szacowania faz.</span><span class="sxs-lookup"><span data-stu-id="65534-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="65534-128">Wzmocnienie amplitudy dla rozwiązań firmy Oracle</span><span class="sxs-lookup"><span data-stu-id="65534-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="65534-129">Algorytm wzmocnienia amplitudy ma na celu przeprowadzenie obrotu między stanem początkowym i końcowym przez zastosowanie sekwencji odbicia stanu.</span><span class="sxs-lookup"><span data-stu-id="65534-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="65534-130">Aby algorytm działał, musi on mieć specyfikację obu tych stanów.</span><span class="sxs-lookup"><span data-stu-id="65534-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="65534-131">Te specyfikacje są podane przez dwie firmy Oracle.</span><span class="sxs-lookup"><span data-stu-id="65534-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="65534-132">Te Oracle działają, dzieląc dane wejściowe na dwie spacje, "miejsce docelowe" i "początkowe" miejsce.</span><span class="sxs-lookup"><span data-stu-id="65534-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="65534-133">Firmy Oracle identyfikują takie miejsca, podobnie jak operatory Pauli identyfikują dwie spacje, stosując fazę $ \Pm $1 do tych miejsc.</span><span class="sxs-lookup"><span data-stu-id="65534-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="65534-134">Główną różnicą jest to, że te miejsca nie muszą zawierać pół miejsca w tej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="65534-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="65534-135">Należy również zauważyć, że te dwa podobszary nie są zwykle wykluczane wzajemnie: istnieją wektory, które są elementami członkowskimi obu spacji.</span><span class="sxs-lookup"><span data-stu-id="65534-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="65534-136">Jeśli ta wartość nie była równa true, wzmocnienie amplitudy nie będzie miało żadnego efektu, dlatego musimy mieć początkowe miejsce, aby nie nakładać się na wartość docelową.</span><span class="sxs-lookup"><span data-stu-id="65534-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="65534-137">Należy zwrócić uwagę na pierwszą firmę Oracle, której potrzebujemy, aby wzmocnienie amplitudy było $P \_ $0, zdefiniowane jako mające następujące działania.</span><span class="sxs-lookup"><span data-stu-id="65534-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="65534-138">Dla wszystkich stanów $ \ket{x} $ w "początkowym" miejscu $P \_ 0 \ket{x} =-\ket{x} $ i dla wszystkich stanów $ \ket{y} $, które nie znajdują się w tym miejscu, $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="65534-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="65534-139">Oracle, który oznacza miejsce docelowe, $P _1 $, ma dokładnie taki sam formularz.</span><span class="sxs-lookup"><span data-stu-id="65534-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="65534-140">Dla wszystkich stanów $ \ket{x} $ w miejscu docelowym (tj. dla wszystkich stanów, które mają być używane przez algorytm), $P _1 \ KET {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="65534-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="65534-141">Podobnie dla wszystkich stanów $ \ket{y} $, które nie znajdują się w docelowym miejscu $P _1 \ KET {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="65534-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="65534-142">Te dwa odbicia są następnie łączone w celu utworzenia operatora, który ustawia pojedynczy krok wzmocnienia amplitudy, $Q =-P_0 P_1 $, gdzie całkowity znak minus jest istotny tylko do uwzględnienia w kontrolowanych aplikacjach.</span><span class="sxs-lookup"><span data-stu-id="65534-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="65534-143">Wzmocnienie amplitudy następnie przechodzi przez pobranie stanu początkowego $ \ket{\psi} $, który znajduje się w początkowym miejscu, a następnie wykonuje $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="65534-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="65534-144">Wykonywanie takich iteracji gwarantuje, że jeśli jeden zaczyna się od początkowego stanu, który nakłada się na $ \sin ^ 2 (\theta) $ z oznaczonym obszarem, po $m $ iteracje to nakładają się $ \sin ^ 2 ([2 mln + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="65534-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="65534-145">Zwykle chcemy wybrać $m $, aby być bezpłatnym parametrem, takim jak $ [2 mln + 1] \theta = \ pi/2 $; jednak takie sztywne wybory nie są uznawane za istotne dla niektórych form wzmocnienia amplitudy, takich jak wzmocnienie amplitudy stałych punktów.</span><span class="sxs-lookup"><span data-stu-id="65534-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="65534-146">Ten proces pozwala nam przygotować stan w oznaczonym miejscu przy użyciu mniej więcej zapytań do funkcji oznaczania i funkcji przygotowania stanu, niż jest to możliwe na ściśle klasycznym urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="65534-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="65534-147">Dzieje się tak dlatego, że wzmocnienie amplitudy jest znaczącym blokiem konstrukcyjnym dla wielu aplikacji przetwarzania Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="65534-148">Aby zrozumieć, jak używać algorytmu, warto podać przykład, który zapewnia konstrukcję rozwiązań firmy Oracle.</span><span class="sxs-lookup"><span data-stu-id="65534-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="65534-149">Rozważ wykonanie algorytmu Grover dla wyszukiwania bazy danych w tym ustawieniu.</span><span class="sxs-lookup"><span data-stu-id="65534-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="65534-150">W wyszukiwaniu Grover celem jest przekształcenie stanu $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket {0} $ w jeden z (potencjalnie) wiele oznaczonych Stanów.</span><span class="sxs-lookup"><span data-stu-id="65534-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="65534-151">Aby jeszcze bardziej uprościć, spójrzmy na przypadek, w którym jedynym oznaczonym stanem jest $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="65534-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="65534-152">Następnie mamy zaprojektować dwie firmy Oracle: jeden oznaczający początkowy stan $ \ket{+} ^ {\otimes n} $ ze znakiem minus, a drugi, który oznacza oznaczony stan $ \ket {0} $ znakiem minus.</span><span class="sxs-lookup"><span data-stu-id="65534-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="65534-153">Tę ostatnią bramę można zaimplementować przy użyciu następującej operacji procesu przy użyciu operacji przepływu sterowania w programie Canon:</span><span class="sxs-lookup"><span data-stu-id="65534-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="65534-154">Ta Oracle jest następnie szczególnym przypadkiem <xref:Microsoft.Quantum.Canon.RAll1> operacji, która umożliwia obracanie przez dowolną fazę zamiast przypadku odbicia $ \phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="65534-154">This oracle is then a special case of the <xref:Microsoft.Quantum.Canon.RAll1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="65534-155">W tym przypadku `RAll1` jest podobny do <xref:Microsoft.Quantum.Intrinsic.R1> operacji Preludium, w tym, że obraca się on o $ \ket{11\cdots1} $ zamiast stanu Single-qubit $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="65534-155">In this case, `RAll1` is similar to the <xref:Microsoft.Quantum.Intrinsic.R1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="65534-156">Oracle, który oznacza początkowe miejsce, może być skonstruowany w podobny sposób.</span><span class="sxs-lookup"><span data-stu-id="65534-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="65534-157">W pseudokodzie:</span><span class="sxs-lookup"><span data-stu-id="65534-157">In pseudocode:</span></span>

1. <span data-ttu-id="65534-158">Zastosuj $H $ brama do każdego qubit.</span><span class="sxs-lookup"><span data-stu-id="65534-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="65534-159">Zastosuj $X $ brama do każdego qubit.</span><span class="sxs-lookup"><span data-stu-id="65534-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="65534-160">Zastosuj $n-$1 kontrolowane $Z $-Gate do $n ^ {\Text{th}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="65534-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="65534-161">Zastosuj $X $ brama do każdego qubit.</span><span class="sxs-lookup"><span data-stu-id="65534-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="65534-162">Zastosuj $H $ brama do każdego qubit.</span><span class="sxs-lookup"><span data-stu-id="65534-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="65534-163">Tym razem pokazujemy również użycie <xref:Microsoft.Quantum.Canon.ApplyWith> razem z <xref:Microsoft.Quantum.Canon.RAll1> opisaną powyżej operacją:</span><span class="sxs-lookup"><span data-stu-id="65534-163">This time, we also demonstrate using <xref:Microsoft.Quantum.Canon.ApplyWith> together with the <xref:Microsoft.Quantum.Canon.RAll1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="65534-164">Następnie możemy połączyć te dwa firmy Oracle, aby obrócić między dwoma stanami i deterministycznie przekształcić $ \ket{+} ^ {\otimes n} $ do $ \ket {0} $ przy użyciu szeregu warstw bramy Hadamard, która jest proporcjonalna do $ \sqrt{2 ^ n} $ (program ie $m \propto \sqrt{2 ^ n} $) zamiast niedeterministycznych warstw $2 ^ n $, które byłyby konieczne do nieuporządkowanego przygotowania stanu $ \ket {0} $ przez przygotowanie i pomiar stanu początkowego do momentu zaobserwowania wyniku $0 $.</span><span class="sxs-lookup"><span data-stu-id="65534-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="65534-165">Fazy oceny rozwiązań firmy Oracle</span><span class="sxs-lookup"><span data-stu-id="65534-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="65534-166">W przypadku szacowania fazy firmy Oracle są nieco bardziej naturalne.</span><span class="sxs-lookup"><span data-stu-id="65534-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="65534-167">Celem szacowania fazy jest zaprojektowanie podprocedury, która może próbkować z eigenvalues macierzy jednostkowej.</span><span class="sxs-lookup"><span data-stu-id="65534-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="65534-168">Ta metoda jest niezbędna w symulacji Quantum, ponieważ w przypadku wielu fizycznych problemów związanych z analizą chemiczną i nauką materiału te eigenvalues zapewniają niedrogią kondycję systemów Quantum, która zapewnia nam cenne informacje o diagramach faz materiałów i dynamiki reakcji dla cząsteczek.</span><span class="sxs-lookup"><span data-stu-id="65534-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="65534-169">Każda wersja oszacowania fazy musi być jednostką wejściową.</span><span class="sxs-lookup"><span data-stu-id="65534-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="65534-170">Ten moduł jest zwykle opisywany przez jeden z dwóch typów rozwiązań firmy Oracle.</span><span class="sxs-lookup"><span data-stu-id="65534-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="65534-171">Oba typy Oracle opisane poniżej zostały omówione w przykładach.</span><span class="sxs-lookup"><span data-stu-id="65534-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="65534-172">Aby dowiedzieć się więcej o programie Oracle Query, zobacz przykład [ **PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="65534-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="65534-173">Aby dowiedzieć się więcej na temat zapytań dyskretnych, zobacz [przykład **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="65534-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="65534-174">Pierwszy typ Oracle, który wywołuje zapytanie dyskretne Oracle i reprezentuje typ zdefiniowany przez użytkownika <xref:Microsoft.Quantum.Oracles.DiscreteOracle> , po prostu obejmuje macierz jednostkową.</span><span class="sxs-lookup"><span data-stu-id="65534-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:Microsoft.Quantum.Oracles.DiscreteOracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="65534-175">Jeśli $U $ jest jednostką, której eigenvalues chcemy oszacować, a firma Oracle dla $U $ jest po prostu dodatkiem do procedury podrzędnej, która implementuje $U $.</span><span class="sxs-lookup"><span data-stu-id="65534-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="65534-176">Na przykład może upłynąć $U $, aby było to Oracle $Q $ zdefiniowany powyżej na potrzeby szacowania amplitudy.</span><span class="sxs-lookup"><span data-stu-id="65534-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="65534-177">Eigenvalues tej macierzy można użyć do oszacowania nakładania się między Stanami początkowymi i docelowymi $ \sin ^ 2 (\theta) $, przy użyciu kwadratów z mniejszą ilością próbek niż w przypadku, w przeciwnym razie będzie potrzebna.</span><span class="sxs-lookup"><span data-stu-id="65534-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="65534-178">Dzięki temu aplikacja do oceny fazy jest uzyskiwana przy użyciu Grover Oracle $Q $ jako dane wejściowe szacowania amplitudy.</span><span class="sxs-lookup"><span data-stu-id="65534-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="65534-179">Inna typowa aplikacja, szeroko wykorzystywana w metrologii Quantum, obejmuje oszacowanie małego kąta obrotu.</span><span class="sxs-lookup"><span data-stu-id="65534-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="65534-180">Innymi słowy, chcemy oszacować $ \theta $ dla nieznanej bramy rotacji w formularzu $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="65534-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="65534-181">W takich przypadkach podprocedura, z którą będziemy korzystać, aby poznać tę stałą wartość $ \theta $ dla bramy to $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ teta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="65534-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="65534-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="65534-182">\end{align} $$</span></span>

<span data-ttu-id="65534-183">Drugim typem Oracle używanym w ocenie fazy jest ciągłe zapytanie Oracle reprezentowane przez <xref:Microsoft.Quantum.Oracles.ContinuousOracle> Typ.</span><span class="sxs-lookup"><span data-stu-id="65534-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:Microsoft.Quantum.Oracles.ContinuousOracle> type.</span></span>
<span data-ttu-id="65534-184">Ciągłe zapytanie Oracle do oceny fazy przyjmuje postać $U (t) $, gdzie $t $ jest znaną w sposób klasyczny.</span><span class="sxs-lookup"><span data-stu-id="65534-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="65534-185">Jeśli możemy $U $ być stałą jednostką, a następnie ciągłe zapytanie Oracle przyjmuje formularz $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="65534-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="65534-186">Pozwala to na badanie macierzy, takich jak $ \sqrt{U} $, które nie mogły zostać zaimplementowane bezpośrednio w modelu zapytań dyskretnych.</span><span class="sxs-lookup"><span data-stu-id="65534-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="65534-187">Ten typ Oracle jest cenny, gdy nie testujesz konkretnej jednostki, ale raczej chcesz poznać właściwości generatora jednostki.</span><span class="sxs-lookup"><span data-stu-id="65534-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="65534-188">Na przykład w dynamicznej symulacji Quantum celem jest opracowanie obwodów Quantum, które blisko przybliżą $U (t) = e ^ {-i H t} $ dla matrycy hermitian $H $ i ewolucyjny czas $t $.</span><span class="sxs-lookup"><span data-stu-id="65534-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="65534-189">Eigenvalues $U (t) $ są bezpośrednio powiązane z eigenvaluesem $H $.</span><span class="sxs-lookup"><span data-stu-id="65534-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="65534-190">Aby to sprawdzić, należy rozważyć eigenvector $H $: $H \ket{E} = E\ket {E} $, a następnie można łatwo sprawdzić od definicji serii potęgowej w macierzy wykładniczej, która $U (t) \ket{E} = e ^ {i\phi} \ KET {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="65534-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="65534-191">W ten sposób szacujemy eigenphase $U (t) $ daje eigenvalue $E $, przy założeniu, że eigenvector $ \ket{E} $ jest wejściem do algorytmu szacowania fazy.</span><span class="sxs-lookup"><span data-stu-id="65534-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="65534-192">Jednak w tym przypadku wartość $t $ może być wybierana według uznania użytkownika, ponieważ w przypadku wystarczającej niskiej wartości $t $ eigenvalue $E $ można jednoznacznie odwrócić przez $E =-\ Fi/t $.</span><span class="sxs-lookup"><span data-stu-id="65534-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="65534-193">Ponieważ metody symulacji Quantum zapewniają możliwość przeprowadzenia ewolucji ułamkowej, to przyznaje ona algorytmom szacowania faz dodatkową swobodę podczas wysyłania zapytań do jednostki, w odróżnieniu od tego, że model zapytań dyskretnych zezwala na unitaries w $U postaci od ^ $t t $ do zastosowanych w przypadku liczby całkowitej $j $U $.</span><span class="sxs-lookup"><span data-stu-id="65534-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="65534-194">Jest to ważne, aby przeprowadzić ściskanie wszystkich ostatnich uncji algorytmów szacowania wydajności, ponieważ pozwala to na wybór dokładnego eksperymentu, który zapewni najwięcej informacji na temat $E $; Metody oparte na dyskretnych zapytaniach muszą podejmować działania, wybierając najlepszą liczbę całkowitą zapytań w algorytmie.</span><span class="sxs-lookup"><span data-stu-id="65534-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="65534-195">W ramach konkretnego przykładu należy wziąć pod uwagę problem związany z oszacowaniem, a nie kąt obrotu bramy, ale częstotliwość przetwarzania w systemie Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="65534-196">Jednostką, która opisuje takie bioquantum Dynamics, jest $U (t) = R_z (2 \ Omega t) $ dla czasu ewolucji $t $ i nieznana częstotliwość $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="65534-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="65534-197">W tym kontekście możemy symulować $U (t) $ dla dowolnego $t $ przy użyciu pojedynczej $R _z $ bramy i ponieważ nie trzeba ograniczać wypróbujemy tylko do zapytań dyskretnych do jednostki.</span><span class="sxs-lookup"><span data-stu-id="65534-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="65534-198">Taki ciągły model ma również właściwość, którą częstotliwości większe niż $2 \ Pi $ można poznać z procesów szacowania fazy, które używają ciągłych zapytań, ponieważ informacje o fazie, które w przeciwnym razie byłyby maskowane przez gałąź — kawałki funkcji logarytmu mogą być ujawnione w wyniku eksperymentów wykonywanych na wartościach niebędących współmiernymi $t $.</span><span class="sxs-lookup"><span data-stu-id="65534-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="65534-199">W związku z tym w przypadku problemów, takich jak te modele ciągłego zapytania dla oceny fazy Oracle, nie tylko są odpowiednie, ale są również preferowane dla dyskretnego modelu zapytań.</span><span class="sxs-lookup"><span data-stu-id="65534-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="65534-200">Z tego powodu Q# Funkcja obejmuje obie formy zapytań i opuszcza go użytkownikowi, aby podjąć decyzję o algorytmie szacowania fazy w celu dopasowania ich do potrzeb i typu dostępnych rozwiązań firmy Oracle.</span><span class="sxs-lookup"><span data-stu-id="65534-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="65534-201">Modelowanie generatora dynamicznego</span><span class="sxs-lookup"><span data-stu-id="65534-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="65534-202">Generatory czasowe opisują sposób, w jaki Stany rozwijają się w czasie.</span><span class="sxs-lookup"><span data-stu-id="65534-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="65534-203">Na przykład element Dynamics elementu Quantum $ \ket{\psi} $ jest regulowany przez równanie Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ z hermitian Matrix $H $, znane jako hamiltonian, jako generator ruchu.</span><span class="sxs-lookup"><span data-stu-id="65534-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="65534-204">Ze względu na stan początkowy $ \ket{\psi (0)} $ w czasie $t = $0, formalne rozwiązanie do tego równania w czasie $t $ może być, w zasadzie, Zapisano $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $, gdzie $U wykładnicze macierzy (t) = e ^ {-i H t} $ jest znany jako jednostkowy operator ewolucyjny czasu.</span><span class="sxs-lookup"><span data-stu-id="65534-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="65534-205">Chociaż skupmy się na generatorach tego formularza w następujący sposób, podkreślamy, że koncepcja jest bardziej szeroka, na przykład w symulacji otwartych systemów Quantum lub do bardziej abstrakcyjnych równań różnicowych.</span><span class="sxs-lookup"><span data-stu-id="65534-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="65534-206">Głównym celem symulacji dynamicznego jest zaimplementowanie operatora ewolucji czasu dla niektórych stanów Quantum zakodowanych w qubits komputera Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="65534-207">W wielu przypadkach hamiltonian może być podzielony na sumę niektórych $d $ prostsze warunki</span><span class="sxs-lookup"><span data-stu-id="65534-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="65534-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="65534-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="65534-209">w przypadku, gdy poszczególne terminy są łatwe do wdrożenia na komputerze Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="65534-210">Na przykład, jeśli $H _j $ jest Pauli $X _1X_2 operatorem, działającym na 1. i 2 elementów rejestru qubit `qubits` , jego czasowe ewolucje w dowolnym momencie $t $ można zaimplementować po prostu, wywołując operację `Exp([PauliX,PauliX], t, qubits[1..2])` , która ma sygnaturę `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="65534-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="65534-211">Jak opisano w dalszej części symulacji hamiltonian, jedno rozwiązanie ma na celu przybliżone ewolucję czasu przez $H $ z sekwencją prostszej operacji</span><span class="sxs-lookup"><span data-stu-id="65534-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="65534-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="65534-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="65534-213">gdzie liczba całkowita $r > $0 kontroluje błąd przybliżenia.</span><span class="sxs-lookup"><span data-stu-id="65534-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="65534-214">Biblioteka modelowania generatora dynamicznego zapewnia strukturę służącą do systematycznego kodowania skomplikowanych generatorów pod kątem łatwiejszych generatorów.</span><span class="sxs-lookup"><span data-stu-id="65534-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="65534-215">Taki opis może zostać następnie przesłany do, powiedzmy, biblioteka symulacji w celu zaimplementowania ewolucji czasu przez wybrany przez Ciebie algorytm symulacji z wieloma szczegółami.</span><span class="sxs-lookup"><span data-stu-id="65534-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="65534-216">Dynamiczna biblioteka generatora opisana poniżej znajduje się w przykładach.</span><span class="sxs-lookup"><span data-stu-id="65534-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="65534-217">Aby zapoznać się z przykładem opartym na modelu Ising, zobacz [przykład **IsingGenerators**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="65534-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="65534-218">Przykład na podstawie wodoru molekularnego można znaleźć w [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) i [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) Samples.</span><span class="sxs-lookup"><span data-stu-id="65534-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="65534-219">Pełny opis generatora</span><span class="sxs-lookup"><span data-stu-id="65534-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="65534-220">Na najwyższym poziomie pełny opis hamiltonian jest zawarty w `EvolutionGenerator` typie zdefiniowanym przez użytkownika, który ma dwa składniki.:</span><span class="sxs-lookup"><span data-stu-id="65534-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="65534-221">`GeneratorSystem`Typ zdefiniowany przez użytkownika to klasyczny opis hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="65534-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="65534-222">Pierwszy element `Int` krotki przechowuje liczbę warunków $d $ w hamiltonian, a drugi element `(Int -> GeneratorIndex)` to funkcja, która mapuje indeks liczby całkowitej w wartości $ \{ 0, 1,..., d-1 \} $ do `GeneratorIndex` typu zdefiniowanego przez użytkownika, który jednoznacznie identyfikuje każdy termin pierwotny w hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="65534-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="65534-223">Należy pamiętać, że przez wyrażenie kolekcji warunków w hamiltonian jako funkcja, a nie jako tablicę `GeneratorIndex[]` , umożliwia to na bieżąco obliczenia, `GeneratorIndex` które jest szczególnie przydatne w przypadku opisywania Hamiltonians z dużą liczbą warunków.</span><span class="sxs-lookup"><span data-stu-id="65534-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="65534-224">Bez względu na to, jakie terminy pierwotne identyfikowane przez `GeneratorIndex` są łatwe do symulowania.</span><span class="sxs-lookup"><span data-stu-id="65534-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="65534-225">Na przykład warunki pierwotne mogą być operatorami Pauli, jak wspomniano powyżej, ale mogą również być Fermionic Annihilation i operatory tworzenia często używane w symulacji chemicznej Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="65534-226">Tak samo nie jest tak samo, jak w przypadku, `GeneratorIndex` gdy nie opisuje on sposobu ewolucji czasu, który wskazuje na to, że może być zaimplementowana jako obwód Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="65534-227">Jest to rozwiązywane przez określenie `EvolutionSet` typu zdefiniowanego przez użytkownika, który mapuje dowolny `GeneratorIndex` , rysowany od pewnego zestawu kanonicznego, do operatora jednostki, `EvolutionUnitary` , wyrażony jako obwód Quantum.</span><span class="sxs-lookup"><span data-stu-id="65534-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="65534-228">`EvolutionSet`Definiuje Konwencję `GeneratorIndex` , jak ma strukturę, a także definiuje zestaw możliwych `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="65534-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="65534-229">Generatory operatorów Pauli</span><span class="sxs-lookup"><span data-stu-id="65534-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="65534-230">Konkretny i przydatny przykład generatorów to Hamiltonians, które są sumą operatorów Pauli, z których każdy może mieć inny współczynnik.</span><span class="sxs-lookup"><span data-stu-id="65534-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="65534-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $, gdzie każdy $ \hat H_j $ jest teraz rysowany z grupy Pauli.</span><span class="sxs-lookup"><span data-stu-id="65534-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="65534-232">W przypadku takich systemów udostępniamy `PauliEvolutionSet()` Typ, `EvolutionSet` który definiuje Konwencję dotyczącą sposobu, w jaki element grupy Pauli i współczynnika mogą być identyfikowane przez `GeneratorIndex` , który ma następujący podpis.</span><span class="sxs-lookup"><span data-stu-id="65534-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="65534-233">W naszym kodowaniu pierwszy parametr `Int[]` określa ciąg Pauli, gdzie $ \Hat I\rightarrow $0, $ \Hat X\rightarrow $1, $ \Hat Y\rightarrow $2 i $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="65534-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="65534-234">Drugi parametr `Double[]` przechowuje współczynnik ciągu Pauli w hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="65534-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="65534-235">Należy zauważyć, że używany jest tylko pierwszy element tej tablicy.</span><span class="sxs-lookup"><span data-stu-id="65534-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="65534-236">Trzeci parametr `Int[]` indeksuje qubits, w którym działa ten ciąg Pauli i nie może zawierać zduplikowanych elementów.</span><span class="sxs-lookup"><span data-stu-id="65534-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="65534-237">W tym celu hamiltonian termin $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ może być reprezentowany jako</span><span class="sxs-lookup"><span data-stu-id="65534-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="65534-238">`PauliEvolutionSet()`To funkcja, która mapuje dowolny `GeneratorIndex` z tych formularzy na `EvolutionUnitary` następujący podpis.</span><span class="sxs-lookup"><span data-stu-id="65534-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="65534-239">Pierwszy parametr reprezentuje czas trwania, który zostanie pomnożony przez współczynnik w `GeneratorIndex` , ewolucji jednostkowej.</span><span class="sxs-lookup"><span data-stu-id="65534-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="65534-240">Drugi parametr to qubit, w którym są rejestrowane działania jednostkowe.</span><span class="sxs-lookup"><span data-stu-id="65534-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="65534-241">Generatory Time-Dependent</span><span class="sxs-lookup"><span data-stu-id="65534-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="65534-242">W wielu przypadkach są również zainteresowani generatorami zależnymi od czasu, które mogą wystąpić w równaniu Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $, gdzie Generator $ \hat H (t) $ jest teraz zależny od czasu.</span><span class="sxs-lookup"><span data-stu-id="65534-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="65534-243">Rozszerzenie od niezależnych generatorów czasowych powyżej do tego przypadku jest proste.</span><span class="sxs-lookup"><span data-stu-id="65534-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="65534-244">Zamiast Naprawiono `GeneratorSystem` hamiltonian $, a w przypadku wszystkich $t godzin nie ma już `GeneratorSystemTimeDependent` typu zdefiniowanego przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="65534-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="65534-245">Pierwszy parametr jest parametrem harmonogramu ciągłego $s \In [0, 1] $, a funkcje tego typu zwracają `GeneratorSystem` dla tego harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="65534-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="65534-246">Należy zauważyć, że parametr Schedule może być liniowo związany z parametrem czasu fizycznego, np. $s = t/T $, przez pewien łączny czas symulacji $T $.</span><span class="sxs-lookup"><span data-stu-id="65534-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="65534-247">Ogólnie rzecz biorąc nie ma to potrzeby.</span><span class="sxs-lookup"><span data-stu-id="65534-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="65534-248">Podobnie, pełny opis tego generatora wymaga `EvolutionSet` , i dlatego definiujemy `EvolutionSchedule` Typ zdefiniowany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="65534-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
