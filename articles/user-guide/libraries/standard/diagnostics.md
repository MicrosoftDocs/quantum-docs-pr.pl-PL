---
title: Diagnostyka w bibliotekach standardowych Q
description: 'Dowiedz się więcej o funkcjach i operacjach diagnostycznych w bibliotekach Q # Standard służących do przechwytywania błędów lub błędów w programach Quantum.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad@microsoft.com
ms.topic: article
ms.openlocfilehash: 324753cfa1b7d940bf5a0bbe7665f19cc6dda82c
ms.sourcegitcommit: cdf67362d7b157254e6fe5c63a1c5551183fc589
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/21/2020
ms.locfileid: "86870638"
---
# <a name="diagnostics"></a><span data-ttu-id="49abf-103">Diagnostyka</span><span class="sxs-lookup"><span data-stu-id="49abf-103">Diagnostics</span></span> #

<span data-ttu-id="49abf-104">Podobnie jak w przypadku klasycznego programowania, ważne jest, aby umożliwić Diagnozowanie błędów i błędów w programach Quantum.</span><span class="sxs-lookup"><span data-stu-id="49abf-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="49abf-105">Biblioteki Q # Standard zapewniają różne sposoby zapewnienia poprawności programów Quantum, jak opisano w temacie <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="49abf-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="49abf-106">W dużym stopniu obsługa ta jest dostępna w formie funkcji i operacji, które powodują, że komputer docelowy dostarcza dodatkowe informacje diagnostyczne do programu hosta lub dewelopera, lub wymusza prawidłowość warunków i nielicznych wyrażonych przez wywołanie funkcji lub operacji.</span><span class="sxs-lookup"><span data-stu-id="49abf-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="49abf-107">Diagnostyka maszyny</span><span class="sxs-lookup"><span data-stu-id="49abf-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="49abf-108">Diagnostykę na temat klasycznych wartości można uzyskać za pomocą <xref:microsoft.quantum.intrinsic.message> funkcji, aby rejestrować komunikat w sposób zależny od maszyny.</span><span class="sxs-lookup"><span data-stu-id="49abf-108">Diagnostics about classical values can be obtained by using the <xref:microsoft.quantum.intrinsic.message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="49abf-109">Domyślnie program zapisuje ciąg w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="49abf-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="49abf-110">Używane razem z interpolowanymi ciągami <xref:microsoft.quantum.intrinsic.message> ułatwia raportowanie informacji diagnostycznych o klasycznych wartościach:</span><span class="sxs-lookup"><span data-stu-id="49abf-110">Used together with interpolated strings, <xref:microsoft.quantum.intrinsic.message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="49abf-111">`Message`ma sygnaturę `(String -> Unit)` reprezentującą, że nie można zaobserwować emitowania komunikatu dziennika debugowania z poziomu Q #.</span><span class="sxs-lookup"><span data-stu-id="49abf-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="49abf-112"><xref:microsoft.quantum.diagnostics.dumpmachine>I w <xref:microsoft.quantum.diagnostics.dumpregister> wyniku tego nakazuje komputerom docelowym dostarczenie informacji diagnostycznych dotyczących wszystkich aktualnie przyznanych qubits lub odpowiednio określonego rejestru qubits.</span><span class="sxs-lookup"><span data-stu-id="49abf-112">The <xref:microsoft.quantum.diagnostics.dumpmachine> and <xref:microsoft.quantum.diagnostics.dumpregister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="49abf-113">Każdy komputer docelowy różni się w zależności od informacji diagnostycznych w odpowiedzi na instrukcję zrzutu.</span><span class="sxs-lookup"><span data-stu-id="49abf-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="49abf-114">Maszyna docelowa [pełnego stanu symulatora](xref:microsoft.quantum.machines.full-state-simulator) , na przykład, udostępnia program hosta z wektorem stanu, którego używa wewnętrznie do reprezentowania rejestru qubits.</span><span class="sxs-lookup"><span data-stu-id="49abf-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="49abf-115">Porównując, komputer docelowy [symulatora Toffoli](xref:microsoft.quantum.machines.toffoli-simulator) zapewnia jeden klasyczny bit dla każdego qubitu.</span><span class="sxs-lookup"><span data-stu-id="49abf-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="49abf-116">Aby dowiedzieć się więcej na temat danych wyjściowych [pełnego symulatora stanu](xref:microsoft.quantum.machines.full-state-simulator) , zapoznaj się z `DumpMachine` sekcją funkcje zrzutu naszego artykułu dotyczącego [testowania i debugowania](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="49abf-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="49abf-117">Fakty i potwierdzenia</span><span class="sxs-lookup"><span data-stu-id="49abf-117">Facts and Assertions</span></span> ##

<span data-ttu-id="49abf-118">Zgodnie z opisem w sekcji [testowanie i debugowanie](xref:microsoft.quantum.guide.testingdebugging), funkcja lub operacja z podpisem `Unit -> Unit` lub `Unit => Unit` odpowiednio, można oznaczyć jako *test jednostkowy*.</span><span class="sxs-lookup"><span data-stu-id="49abf-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="49abf-119">Każdy test jednostkowy zwykle składa się z małego programu Quantum oraz co najmniej jednego warunku, który sprawdza poprawność tego programu.</span><span class="sxs-lookup"><span data-stu-id="49abf-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="49abf-120">Warunki te mogą mieć postać _faktów_, które sprawdzają wartości danych wejściowych lub _zatwierdzeń_, które sprawdzają Stany jednego lub więcej qubitsów, które zostały przesłane jako dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="49abf-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="49abf-121">Na przykład, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` reprezentuje fakt matematyczny, że $1 + 1 = $2, natomiast `AssertQubit(One, qubit)` reprezentuje warunek, który mierzy `qubit` zwraca `One` z pewnością.</span><span class="sxs-lookup"><span data-stu-id="49abf-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="49abf-122">W poprzednim przypadku można sprawdzić poprawność warunku, używając tylko jego wartości, a w tym drugim musimy wiedzieć coś o stanie qubit, aby oszacować potwierdzenie.</span><span class="sxs-lookup"><span data-stu-id="49abf-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="49abf-123">Biblioteki Q # Standard zapewniają kilka różnych funkcji służących do reprezentowania faktów, w tym:</span><span class="sxs-lookup"><span data-stu-id="49abf-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a><span data-ttu-id="49abf-124">Testowanie Stanów qubit</span><span class="sxs-lookup"><span data-stu-id="49abf-124">Testing Qubit States</span></span> ###

<span data-ttu-id="49abf-125">W praktyce potwierdzenia opierają się na faktach, że klasyczne symulacje Quantum Mechanics nie muszą przestrzegać [theorem bez klonowania](https://arxiv.org/abs/quant-ph/9607018), tak że firma Microsoft może wprowadzać niefizyczne pomiary i potwierdzenia przy użyciu symulatora dla naszej maszyny docelowej.</span><span class="sxs-lookup"><span data-stu-id="49abf-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="49abf-126">W ten sposób można testować poszczególne operacje w klasycznym symulatorze przed wdrożeniem na sprzęcie.</span><span class="sxs-lookup"><span data-stu-id="49abf-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="49abf-127">Na komputerach docelowych, które nie pozwalają na ocenę potwierdzeń, wywołania <xref:microsoft.quantum.diagnostics.assertmeasurement> można bezpiecznie zignorować.</span><span class="sxs-lookup"><span data-stu-id="49abf-127">On target machines which do not allow evaluation of assertions, calls to <xref:microsoft.quantum.diagnostics.assertmeasurement> can be safely ignored.</span></span>

<span data-ttu-id="49abf-128">Ogólnie rzecz biorąc, <xref:microsoft.quantum.diagnostics.assertmeasurement> potwierdzenie operacji, które mierzą podaną qubits na podstawie podaną wartość Pauli, będzie zawsze mieć dany wynik.</span><span class="sxs-lookup"><span data-stu-id="49abf-128">More generally, the <xref:microsoft.quantum.diagnostics.assertmeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="49abf-129">Jeśli potwierdzenie nie powiedzie się, wykonywanie kończy się przez wywołanie `fail` z podanym komunikatem.</span><span class="sxs-lookup"><span data-stu-id="49abf-129">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="49abf-130">Domyślnie ta operacja nie jest zaimplementowana. symulatory, które mogą ją obsługiwać, powinny dostarczyć implementację, która przeprowadza sprawdzanie środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="49abf-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="49abf-131">`AssertMeasurement`ma sygnaturę `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="49abf-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="49abf-132">Ponieważ `AssertMeasurement` jest funkcją z pustą krotką jako typem danych wyjściowych, żadne skutki z wywołania nie `AssertMeasurement` są zauważalne w ramach programu Q #.</span><span class="sxs-lookup"><span data-stu-id="49abf-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="49abf-133"><xref:microsoft.quantum.diagnostics.assertmeasurementprobability>Wyniki funkcji operacji, które mierzą podaną qubits w danej Pauli, będą miały wynik z danym prawdopodobieństwem, w ramach pewnej tolerancji.</span><span class="sxs-lookup"><span data-stu-id="49abf-133">The <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="49abf-134">Tolerancja jest dodatkiem (np. `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="49abf-134">Tolerance is additive (e.g. `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="49abf-135">Jeśli potwierdzenie nie powiedzie się, wykonywanie kończy się przez wywołanie `fail` z podanym komunikatem.</span><span class="sxs-lookup"><span data-stu-id="49abf-135">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="49abf-136">Domyślnie ta operacja nie jest zaimplementowana. symulatory, które mogą ją obsługiwać, powinny dostarczyć implementację, która przeprowadza sprawdzanie środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="49abf-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="49abf-137">`AssertMeasurementProbability`ma sygnaturę `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="49abf-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="49abf-138">Pierwszy z `Double` parametrów daje odpowiednie prawdopodobieństwo wyniku, a druga na tolerancję.</span><span class="sxs-lookup"><span data-stu-id="49abf-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="49abf-139">Możemy wykonać więcej niż potwierdzenie pojedynczej miary przy użyciu, że klasyczne informacje używane przez symulator do reprezentowania wewnętrznego stanu qubit są możliwe do skopiowania, dzięki czemu nie ma potrzeby faktycznego przeprowadzenia pomiaru w celu przetestowania naszej potwierdzenia.</span><span class="sxs-lookup"><span data-stu-id="49abf-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="49abf-140">W szczególności pozwala nam przyczynić się do *niezgodności* pomiarów, które byłyby niemożliwe na rzeczywistym sprzęcie.</span><span class="sxs-lookup"><span data-stu-id="49abf-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="49abf-141">Załóżmy, że `P : Qubit => Unit` jest operacją zaplanowaną do przygotowania stanu $ \ket{\psi} $, gdy jego dane wejściowe są w stanie $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="49abf-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="49abf-142">Niech $ \ket{\psi "} $ jest bieżącym stanem przygotowanym przez `P` .</span><span class="sxs-lookup"><span data-stu-id="49abf-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="49abf-143">Następnie $ \ket{\psi} = \ket{\psi '} $ If i tylko wtedy, gdy pomiar $ \ket{\psi '} $ na osi opisanej przez $ \ket{\psi} $ zawsze zwraca `Zero` .</span><span class="sxs-lookup"><span data-stu-id="49abf-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="49abf-144">Oznacza to, że \begin{align} \ket{\psi} = \ket{\psi '} \Text{if i tylko wtedy, gdy} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="49abf-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="49abf-145">\end{align} przy użyciu operacji pierwotnych zdefiniowanych w Preludium, możemy bezpośrednio wykonać pomiary, która zwraca, `Zero` Jeśli $ \ket{\psi} $ jest eigenstate jednego z operatorów Pauli.</span><span class="sxs-lookup"><span data-stu-id="49abf-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="49abf-146">Operacja <xref:microsoft.quantum.diagnostics.assertqubit> zawiera szczególnie przydatne skróty, które należy wykonać w przypadku, gdy chcemy przetestować potwierdzenie $ \ket{\psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="49abf-146">The operation <xref:microsoft.quantum.diagnostics.assertqubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="49abf-147">Jest to typowe, na przykład, gdy firma Microsoft nie przeliczyła, aby zwracała Ancilla qubits do $ \ket {0} $ przed ich zwolnieniem.</span><span class="sxs-lookup"><span data-stu-id="49abf-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="49abf-148">Potwierdzenie dla $ \ket $ jest również przydatne, gdy chcemy zastanowić się, {0} że dwa przygotowania stanu `P` i `Q` operacje przygotowywają ten sam stan, a w przypadku ich `Q` obsługi `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="49abf-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="49abf-149">W szczególności,</span><span class="sxs-lookup"><span data-stu-id="49abf-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="49abf-150">Zwykle jednak firma Microsoft może nie mieć dostępu do potwierdzeń o stanach, które nie pokrywają się z eigenstates operatorów Pauli.</span><span class="sxs-lookup"><span data-stu-id="49abf-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="49abf-151">Na przykład $ \ket{\psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ nie jest eigenstateem żadnego operatora Pauli, w taki sposób, że nie można użyć, <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> Aby jednoznacznie określić, że stan $ \ket{\psi '} $ jest równy $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="49abf-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="49abf-152">Zamiast tego musimy rozłożyć potwierdzenie $ \ket{\psi '} = \ket{\psi} $ do założeń, które mogą być testowane bezpośrednio przy użyciu elementów podstawowych obsługiwanych przez nasz symulator.</span><span class="sxs-lookup"><span data-stu-id="49abf-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="49abf-153">W tym celu pozwól $ \ket{\psi} = \Alpha \ket {0} + \beta \ket {1} $ dla liczb zespolonych $ \Alpha = a i \_ \_ $ i $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="49abf-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="49abf-154">Należy zauważyć, że to wyrażenie wymaga czterech liczb rzeczywistych $ \{ a \_ r, a \_ i, b \_ r, b \_ i \} $ do określenia, ponieważ każda liczba zespolona może być wyrażona jako suma części rzeczywistej i urojonej.</span><span class="sxs-lookup"><span data-stu-id="49abf-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="49abf-155">Ze względu na globalną fazę można jednak wybrać $a \_ i = $0, aby w unikatowy sposób określić tylko trzy rzeczywiste liczby.</span><span class="sxs-lookup"><span data-stu-id="49abf-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="49abf-156">W tym celu należy określić trzy potwierdzenia, które są niezależne od siebie, aby potwierdzić oczekiwany stan.</span><span class="sxs-lookup"><span data-stu-id="49abf-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="49abf-157">Możemy to zrobić przez znalezienie prawdopodobieństwa przestrzegania `Zero` dla każdego pomiaru Pauli podaną $ \Alpha $ i $ \beta $, i potwierdzeń każdego niezależnie.</span><span class="sxs-lookup"><span data-stu-id="49abf-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="49abf-158">Zezwól $x $, $y $ i $z $ `Result` na wartości Pauli $X $, $Y $ i $Z $ pomiarów.</span><span class="sxs-lookup"><span data-stu-id="49abf-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="49abf-159">Następnie przy użyciu funkcji prawdopodobieństwo dla pomiarów Quantum, \begin{align} \Pr (x = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{zero} | \Alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a ^ 2 \_ + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="49abf-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="49abf-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="49abf-160">\end{align}</span></span>

<span data-ttu-id="49abf-161"><xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance>Operacja implementuje te potwierdzenia w postaci reprezentacji $ \Alpha $ i $ \beta $ jako wartości typu <xref:microsoft.quantum.math.complex> .</span><span class="sxs-lookup"><span data-stu-id="49abf-161">The <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:microsoft.quantum.math.complex>.</span></span>
<span data-ttu-id="49abf-162">Jest to przydatne, gdy oczekiwany stan można obliczyć matematycznie.</span><span class="sxs-lookup"><span data-stu-id="49abf-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="49abf-163">Potwierdzanie równości operacji Quantum</span><span class="sxs-lookup"><span data-stu-id="49abf-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="49abf-164">Z tego względu firma Microsoft miała już do końca operacje testowania, które są przeznaczone do przygotowania określonych stanów.</span><span class="sxs-lookup"><span data-stu-id="49abf-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="49abf-165">Często jednak interesuje, jak operacja działa w przypadku dowolnych danych wejściowych, a nie dla pojedynczego stałego wejścia.</span><span class="sxs-lookup"><span data-stu-id="49abf-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="49abf-166">Załóżmy na przykład, że wprowadziliśmy operację `U : ((Double, Qubit[]) => () : Adjoint)` odpowiadającą rodzinie operatorów jednostkowych $U (t) $, i podano jawnie `adjoint` blok zamiast używać `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="49abf-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="49abf-167">Firma Microsoft może chcieć zainteresować, że $U ^ \dagger (t) = U (-t) $, zgodnie z oczekiwaniami, jeśli $t $ reprezentuje czas ewolucji.</span><span class="sxs-lookup"><span data-stu-id="49abf-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="49abf-168">Ogólnie mówiąc, istnieją dwie różne strategie, które możemy wykonać w celu potwierdzenia, że dwie operacje `U` i `V` działają identycznie.</span><span class="sxs-lookup"><span data-stu-id="49abf-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="49abf-169">Po pierwsze można sprawdzić, czy `U(target); (Adjoint V)(target);` zachowuje wszystkie Stany.</span><span class="sxs-lookup"><span data-stu-id="49abf-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="49abf-170">Po drugie możemy sprawdzić, czy `U(target); (Adjoint V)(target);` działa on w połowie stanu Entangled. zachowuje to Entanglement.</span><span class="sxs-lookup"><span data-stu-id="49abf-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="49abf-171">Te strategie są implementowane przez operacje firmy Canon <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> i <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced> odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="49abf-171">These strategies are implemented by the canon operations <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> and <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="49abf-172">Wymienione powyżej potwierdzenie zostało omówione w oparciu o [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), matematyczną strukturę, która odnosi się do operacji na $n $ qubits do Entangled Stanów na $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="49abf-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="49abf-173">W szczególności operacja Identity na $n $ qubits jest reprezentowana przez $n $ kopie Entangled State $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="49abf-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="49abf-174">Operacja <xref:microsoft.quantum.preparation.preparechoistate> implementuje ten isomorphism, przygotowując stan, który reprezentuje daną operację.</span><span class="sxs-lookup"><span data-stu-id="49abf-174">The operation <xref:microsoft.quantum.preparation.preparechoistate> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="49abf-175">W przybliżeniu te strategie są rozróżniane w zależności od czasu.</span><span class="sxs-lookup"><span data-stu-id="49abf-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="49abf-176">Iteracja przez każdy stan wejściowy zabiera dodatkowy czas, podczas gdy użycie Entanglement jako odniesienia wymaga przechowywania dodatkowych qubits.</span><span class="sxs-lookup"><span data-stu-id="49abf-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="49abf-177">W przypadkach, gdy operacja implementuje odwracalną operację klasyczną, na przykład w przypadku, gdy interesuje mnie tylko w przypadku Stanów bazowych obliczeń, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> testy równości dotyczące tego ograniczonego zestawu danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="49abf-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="49abf-178">Iteracja w Stanach wejściowych jest obsługiwana przez operacje wyliczania <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> i <xref:microsoft.quantum.canon.iteratethroughcartesianpower> .</span><span class="sxs-lookup"><span data-stu-id="49abf-178">The iteration over input states is handled by the enumeration operations <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> and <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span></span>
> <span data-ttu-id="49abf-179">Te operacje są bardziej ogólnie przydatne w przypadku stosowania operacji do każdego elementu kartezjańskiego produktu między dwoma lub więcej zestawami.</span><span class="sxs-lookup"><span data-stu-id="49abf-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="49abf-180">Jednak te dwa podejścia przetestują różne właściwości operacji pod kontrolą.</span><span class="sxs-lookup"><span data-stu-id="49abf-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="49abf-181">Ponieważ potwierdzenie w miejscu wywołuje każdą operację wiele razy, raz dla każdego stanu danych wejściowych, wszystkie losowe wybory i wyniki pomiarów mogą ulec zmianie między wywołaniami.</span><span class="sxs-lookup"><span data-stu-id="49abf-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="49abf-182">Z drugiej strony potwierdzenie odwołania wywołuje każdą operację dokładnie raz, aby sprawdzać, czy operacje są równe *pojedynczego zrzutu*.</span><span class="sxs-lookup"><span data-stu-id="49abf-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="49abf-183">Oba te testy są przydatne w celu zapewnienia poprawności programów Quantum.</span><span class="sxs-lookup"><span data-stu-id="49abf-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="49abf-184">Dalsze informacje</span><span class="sxs-lookup"><span data-stu-id="49abf-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:microsoft.quantum.diagnostics>
