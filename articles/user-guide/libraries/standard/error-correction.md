---
title: 'Korekcja błędów w Q# bibliotekach standardowych'
description: 'Dowiedz się, jak używać poprawiania kodów błędów w Q# programach, chroniąc stan qubits.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 94251e185cea65c5fc08ed70d5fba9b7b19501e3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692047"
---
# <a name="error-correction"></a><span data-ttu-id="c4e22-103">Korekcja błędów</span><span class="sxs-lookup"><span data-stu-id="c4e22-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="c4e22-104">Wprowadzenie</span><span class="sxs-lookup"><span data-stu-id="c4e22-104">Introduction</span></span> ##

<span data-ttu-id="c4e22-105">W przypadku klasycznego przetwarzania danych, jeśli jeden chce chronić bit przed błędami, może być często wystarcza do reprezentowania tego bitu przez *bit logiczny* przez powtarzanie bitu danych.</span><span class="sxs-lookup"><span data-stu-id="c4e22-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="c4e22-106">Na przykład niech $ \overline {0} = $0 to kodowanie danych bit 0, gdzie używamy linii powyżej etykiety 0, aby wskazać, że jest to kodowanie bitu w stanie 0.</span><span class="sxs-lookup"><span data-stu-id="c4e22-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="c4e22-107">Jeśli w podobny sposób zezwolimy {1} na $ \overline = $111, mamy prosty kod powtarzania chroniący przed dowolnym błędem bitu przerzucania.</span><span class="sxs-lookup"><span data-stu-id="c4e22-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="c4e22-108">Oznacza to, że jeśli którykolwiek z trzech bitów zostanie przerzucony, można odzyskać stan bitu logicznego, pobierając większość głosów.</span><span class="sxs-lookup"><span data-stu-id="c4e22-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="c4e22-109">Chociaż klasycznej korekcji błędów jest znacznie bardziej zaawansowana, że ten konkretny przykład (zalecamy [wprowadzenie do teorii lint](https://www.springer.com/us/book/9783540641339)), kod powtórzenia powyżej już wskazuje na możliwy problem w ochronie informacji Quantum.</span><span class="sxs-lookup"><span data-stu-id="c4e22-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="c4e22-110">Oznacza to, że w przypadku, gdy [theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) się, że w przypadku każdej indywidualnej qubit i podania większości głosu przez analogię do klasycznego kodu powyżej zostanie utracone dokładne informacje, które próbujesz chronić.</span><span class="sxs-lookup"><span data-stu-id="c4e22-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="c4e22-111">W ustawieniu Quantum zobaczymy, że pomiar ma problemy.</span><span class="sxs-lookup"><span data-stu-id="c4e22-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="c4e22-112">Nadal możemy zaimplementować powyższe kodowanie.</span><span class="sxs-lookup"><span data-stu-id="c4e22-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="c4e22-113">Warto to zrobić, aby zobaczyć, jak możemy uogólniać korekcję błędów do przypadku Quantum.</span><span class="sxs-lookup"><span data-stu-id="c4e22-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="c4e22-114">W tym celu pozwól $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket \otimes {0} \ket {0} $ i let $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="c4e22-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="c4e22-115">Następnie, według liniowości, definiujemy kod powtarzania dla wszystkich danych wejściowych; na przykład $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="c4e22-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="c4e22-116">W szczególności, dzięki czemu błąd przerzucania bitów $X _1 $ Act na środkowym qubitu, zobaczymy, że korekta wymagana w obu gałęziach jest precyzyjna $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="c4e22-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="c4e22-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="c4e22-117">\end{align} $$</span></span>

<span data-ttu-id="c4e22-118">Aby dowiedzieć się, w jaki sposób można określić, że jest to przypadek bez mierzenia bardzo stanu, który próbujesz chronić, warto napisać, co każdy inny błąd przerzucania bitów ma wpływ na nasze Stany logiczne:</span><span class="sxs-lookup"><span data-stu-id="c4e22-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="c4e22-119">Błąd $E $</span><span class="sxs-lookup"><span data-stu-id="c4e22-119">Error $E$</span></span> | <span data-ttu-id="c4e22-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="c4e22-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="c4e22-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="c4e22-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c4e22-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="c4e22-122">$\boldone$</span></span> | <span data-ttu-id="c4e22-123">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-123">$\ket{000}$</span></span> | <span data-ttu-id="c4e22-124">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-124">$\ket{111}$</span></span> |
| <span data-ttu-id="c4e22-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-125">$X_0$</span></span> | <span data-ttu-id="c4e22-126">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-126">$\ket{100}$</span></span> | <span data-ttu-id="c4e22-127">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-127">$\ket{011}$</span></span> |
| <span data-ttu-id="c4e22-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-128">$X_1$</span></span> | <span data-ttu-id="c4e22-129">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-129">$\ket{010}$</span></span> | <span data-ttu-id="c4e22-130">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-130">$\ket{101}$</span></span> |
| <span data-ttu-id="c4e22-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-131">$X_2$</span></span> | <span data-ttu-id="c4e22-132">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-132">$\ket{001}$</span></span> | <span data-ttu-id="c4e22-133">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-133">$\ket{110}$</span></span> |

<span data-ttu-id="c4e22-134">Aby chronić stan, który jest kodowany, musimy mieć możliwość odróżnienia trzech błędów od siebie i od tożsamości $ \boldone $ bez rozróżniania między $ \ket{\overline {0} } $ i $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="c4e22-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="c4e22-135">Na przykład jeśli mierzę $Z _0 $, uzyskamy różne wyniki dla $ \ket{\overline {0} } $ i $ \ket{\overline {1} } $ w przypadku braku błędów, więc zwija zakodowany stan.</span><span class="sxs-lookup"><span data-stu-id="c4e22-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="c4e22-136">Z drugiej strony należy rozważyć zmierzenie $Z _0 Z_1 $, parzystość pierwszych dwóch bitów w każdym stanie bazowym.</span><span class="sxs-lookup"><span data-stu-id="c4e22-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="c4e22-137">Należy odwołać się do każdego pomiaru operatora Pauli, który eigenvalue mierzony stan odpowiada, więc dla każdego stanu $ \ket{\psi} $ w powyższej tabeli możemy obliczyć $Z _0 Z_1 \ket{\psi} $, aby zobaczyć, czy otrzymamy $ \pm\ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="c4e22-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="c4e22-138">Należy zauważyć, że $Z _0 Z_1 \ket {000} = \ket {000} $ i że $Z _0 Z_1 \ket {111} = \ket {111} $, dlatego zakończymy, że ta miara jest taka sama jak w przypadku obu zakodowanych Stanów.</span><span class="sxs-lookup"><span data-stu-id="c4e22-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="c4e22-139">Z drugiej strony $Z _0 Z_1 \ket {100} =-\ket {100} $ i $Z _0 Z_1 \ket {011} =-\ket {011} $, dlatego wynik pomiaru $Z _0 Z_1 $ ujawnia przydatne informacje o wystąpieniu błędu.</span><span class="sxs-lookup"><span data-stu-id="c4e22-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="c4e22-140">Aby to wyróżnić, powtórzmy powyższą tabelę, ale Dodaj wyniki pomiaru $Z _0 Z_1 $ i $Z _1 Z_2 $ w każdym wierszu.</span><span class="sxs-lookup"><span data-stu-id="c4e22-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="c4e22-141">Wyniki każdego pomiaru są notowane według znaku zaobserwowanego eigenvalue, czyli $ + $ lub $-$, Q# `Result` odpowiednio do wartości `Zero` i `One` .</span><span class="sxs-lookup"><span data-stu-id="c4e22-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="c4e22-142">Błąd $E $</span><span class="sxs-lookup"><span data-stu-id="c4e22-142">Error $E$</span></span> | <span data-ttu-id="c4e22-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="c4e22-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="c4e22-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="c4e22-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="c4e22-145">Wynik $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="c4e22-146">Wynik $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="c4e22-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="c4e22-147">$\boldone$</span></span> | <span data-ttu-id="c4e22-148">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-148">$\ket{000}$</span></span> | <span data-ttu-id="c4e22-149">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="c4e22-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-150">$X_0$</span></span> | <span data-ttu-id="c4e22-151">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-151">$\ket{100}$</span></span> | <span data-ttu-id="c4e22-152">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="c4e22-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-153">$X_1$</span></span> | <span data-ttu-id="c4e22-154">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-154">$\ket{010}$</span></span> | <span data-ttu-id="c4e22-155">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="c4e22-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="c4e22-156">$X_2$</span></span> | <span data-ttu-id="c4e22-157">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-157">$\ket{001}$</span></span> | <span data-ttu-id="c4e22-158">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="c4e22-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="c4e22-159">W rezultacie wyniki dwóch pomiarów jednoznacznie decydują o tym, który wystąpił błąd podczas przerzucania bitów, ale bez ujawniania informacji o tym, który ze stanem został zakodowany.</span><span class="sxs-lookup"><span data-stu-id="c4e22-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="c4e22-160">Nazywamy te wyniki *Syndrome* i zapoznaj się z procesem mapowania Syndrome z powrotem do błędu, który spowodował *odzyskanie* .</span><span class="sxs-lookup"><span data-stu-id="c4e22-160">We call these results a *syndrome* , and refer to the process of mapping a syndrome back to the error that caused it as *recovery* .</span></span>
<span data-ttu-id="c4e22-161">W szczególności podkreślamy, że odzyskiwanie jest *klasyczną* procedurą wnioskowania, która przyjmuje jako dane wejściowe Syndrome, która wystąpiła, i zwraca receptę dotyczącą sposobu naprawy wszelkich błędów, które mogły wystąpić.</span><span class="sxs-lookup"><span data-stu-id="c4e22-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="c4e22-162">Powyższy kod bitowy można poprawić tylko w przypadku błędów pojedynczej transmisji bitów. oznacza to, że `X` operacja działa na jednym qubit.</span><span class="sxs-lookup"><span data-stu-id="c4e22-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="c4e22-163">Zastosowanie `X` do więcej niż jednego qubit spowoduje zamapowanie $ \ket{\overline {0} } $ do $ \ket{\overline {1} } $ po odzyskaniu.</span><span class="sxs-lookup"><span data-stu-id="c4e22-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="c4e22-164">Podobnie zastosowanie operacji przerzucenia fazy `Z` spowoduje zamapowanie $ \ket{\overline {1} } $ do $-\ket{\overline {1} } $, a tym samym zamapowanie $ \ket{\overline{+}} $ do $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="c4e22-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="c4e22-165">Bardziej ogólnie rzecz biorąc, kody mogą być tworzone w celu obsługi większej liczby błędów oraz do obsługi $Z $ błędów, a także $X $ błędy.</span><span class="sxs-lookup"><span data-stu-id="c4e22-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="c4e22-166">Szczegółowe informacje o tym, że możemy opisać miary w korekcji błędów Quantum, które działają tak samo jak w przypadku wszystkich stanów kodu, jest istoty *formalnego stabilizacji* .</span><span class="sxs-lookup"><span data-stu-id="c4e22-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism* .</span></span>
<span data-ttu-id="c4e22-167">Q#Canon oferuje strukturę służącą do opisywania kodowania i dekodowania od kodów stabilizatorów oraz do opisywania, jak jeden odzyskuje błędy.</span><span class="sxs-lookup"><span data-stu-id="c4e22-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="c4e22-168">W tej sekcji opisano te struktury i jej aplikacje do kilku prostych kodów korygujących błędów Quantum.</span><span class="sxs-lookup"><span data-stu-id="c4e22-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="c4e22-169">Pełne wprowadzenie do formalnego stabilizacji wykracza poza zakres tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="c4e22-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="c4e22-170">Czytelnicy chcą uzyskać więcej informacji na temat [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="c4e22-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="c4e22-171">Reprezentuje kody poprawiające błędy w Q#</span><span class="sxs-lookup"><span data-stu-id="c4e22-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="c4e22-172">Aby pomóc w określeniu poprawnych kodów błędów, Q# Canon oferuje kilka różnych typów zdefiniowanych przez użytkownika:</span><span class="sxs-lookup"><span data-stu-id="c4e22-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="c4e22-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Wskazuje, że rejestr qubits powinien być interpretowany jako blok kodu poprawiania błędów.</span><span class="sxs-lookup"><span data-stu-id="c4e22-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="c4e22-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Wskazuje, że Tablica wyników pomiaru powinna być interpretowana jako Syndrome mierzona w bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="c4e22-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="c4e22-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Wskazuje, że *klasyczna* funkcja powinna być używana do interpretowania Syndrome i zwracania korekty, która powinna zostać zastosowana.</span><span class="sxs-lookup"><span data-stu-id="c4e22-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="c4e22-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Wskazuje, że operacja pobiera qubits reprezentujący dane wraz z świeżą Ancilla qubits w celu utworzenia bloku kodu w kodzie korygującym błędu.</span><span class="sxs-lookup"><span data-stu-id="c4e22-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="c4e22-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Wskazuje, że operacja dekomponowa blok kodu błędu poprawiania kodu do qubits danych i qubits Ancilla używany do reprezentowania informacji o Syndrome.</span><span class="sxs-lookup"><span data-stu-id="c4e22-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="c4e22-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Oznacza operację, która powinna być używana do wyodrębniania informacji Syndrome z bloku kodu, bez zakłócania stanu chronionego przez kod.</span><span class="sxs-lookup"><span data-stu-id="c4e22-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="c4e22-179">Na koniec, Canon dostarcza <xref:Microsoft.Quantum.ErrorCorrection.QECC> Typ do zbierania innych typów wymaganych do zdefiniowania kodu korygującego błąd QUANTUM.</span><span class="sxs-lookup"><span data-stu-id="c4e22-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="c4e22-180">Skojarzona z każdym z kodów Quantum dla stabilizatorów to długość kodu $n $, numer $k $ qubits logicznego i minimalna odległość $d $, często wygodnie pogrupowane w notacji ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="c4e22-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="c4e22-181">Na przykład <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> Funkcja definiuje ⟦ 3, 1, 1 ⟧ bitowego przerzucenia:</span><span class="sxs-lookup"><span data-stu-id="c4e22-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="c4e22-182">Należy zauważyć, że `QECC` Typ *nie* zawiera funkcji odzyskiwania.</span><span class="sxs-lookup"><span data-stu-id="c4e22-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="c4e22-183">Dzięki temu można zmienić funkcję odzyskiwania używaną w korygowaniu błędów bez zmiany definicji samego kodu; Ta możliwość jest szczególnie przydatna w przypadku uwzględniania informacji zwrotnych z pomiarów scharakteryzowania w modelu przyjętym przez funkcję odzyskiwania.</span><span class="sxs-lookup"><span data-stu-id="c4e22-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="c4e22-184">Po zdefiniowaniu kodu w ten sposób możemy użyć <xref:Microsoft.Quantum.ErrorCorrection.Recover> operacji do odzyskania po błędach:</span><span class="sxs-lookup"><span data-stu-id="c4e22-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="c4e22-185">Więcej szczegółów znajduje się w [przykładowym kodzie przerzucania bitowego](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="c4e22-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="c4e22-186">W odniesieniu do kodu bitowego przewrócenia, Q# Canon jest dostarczany z implementacją [qubit doskonałego kodu](https://arxiv.org/abs/quant-ph/9602019), a także [kod siedmiu qubit](https://arxiv.org/abs/quant-ph/9705052), oba mogą poprawić dowolny błąd pojedynczego qubit.</span><span class="sxs-lookup"><span data-stu-id="c4e22-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
